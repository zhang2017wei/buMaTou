'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Taro = require('@tarojs/api');
var router = require('@tarojs/router');
var runtime = require('@tarojs/runtime');
var base64Js = require('base64-js');
var MobileDetect = require('mobile-detect');
var queryString = require('query-string');
require('whatwg-fetch');
var jsonpRetry = require('jsonp-retry');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Taro__default = /*#__PURE__*/_interopDefaultLegacy(Taro);
var MobileDetect__default = /*#__PURE__*/_interopDefaultLegacy(MobileDetect);
var jsonpRetry__default = /*#__PURE__*/_interopDefaultLegacy(jsonpRetry);

/**
 * ease-in-out的函数
 * @param t 0-1的数字
 */
const easeInOut = (t) => (t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1);
const getTimingFunc = (easeFunc, frameCnt) => {
    return x => {
        if (frameCnt <= 1) {
            return easeFunc(1);
        }
        const t = x / (frameCnt - 1);
        return easeFunc(t);
    };
};

function throttle(fn, threshold = 250, scope) {
    let lastTime = 0;
    let deferTimer;
    return function (...args) {
        const context = scope || this;
        const now = Date.now();
        if (now - lastTime > threshold) {
            fn.apply(this, args);
            lastTime = now;
        }
        else {
            clearTimeout(deferTimer);
            deferTimer = setTimeout(() => {
                lastTime = now;
                fn.apply(context, args);
            }, threshold);
        }
    };
}
function debounce(fn, ms = 250, scope) {
    let timer;
    return function (...args) {
        const context = scope || this;
        clearTimeout(timer);
        timer = setTimeout(function () {
            fn.apply(context, args);
        }, ms);
    };
}

function isFunction(obj) {
    return typeof obj === 'function';
}
const VALID_COLOR_REG = /^#[0-9a-fA-F]{6}$/;
const isValidColor = (color) => {
    return VALID_COLOR_REG.test(color);
};

/* eslint-disable prefer-promise-reject-errors */
function shouldBeObject(target) {
    if (target && typeof target === 'object')
        return { flag: true };
    return {
        flag: false,
        msg: getParameterError({
            correct: 'Object',
            wrong: target
        })
    };
}
function findDOM(inst) {
    const runtimeHooks = runtime.container.get(runtime.SERVICE_IDENTIFIER.Hooks);
    if (inst) {
        const find = runtimeHooks.getDOMNode;
        if (typeof find === 'function') {
            return find(inst);
        }
    }
    const page = runtime.Current.page;
    const path = page === null || page === void 0 ? void 0 : page.path;
    const msg = '没有找到已经加载了的页面，请在页面加载完成后时候此 API。';
    if (path == null) {
        throw new Error(msg);
    }
    const el = document.getElementById(path);
    if (el == null) {
        throw new Error('在已加载页面中没有找到对应的容器元素。');
    }
    return el;
}
function getParameterError({ name = '', para, correct, wrong }) {
    const parameter = para ? `parameter.${para}` : 'parameter';
    const errorType = upperCaseFirstLetter(wrong === null ? 'Null' : typeof wrong);
    if (name) {
        return `${name}:fail parameter error: ${parameter} should be ${correct} instead of ${errorType}`;
    }
    else {
        return `parameter error: ${parameter} should be ${correct} instead of ${errorType}`;
    }
}
function upperCaseFirstLetter(string) {
    if (typeof string !== 'string')
        return string;
    string = string.replace(/^./, match => match.toUpperCase());
    return string;
}
function inlineStyle(style) {
    let res = '';
    for (const attr in style)
        res += `${attr}: ${style[attr]};`;
    if (res.indexOf('display: flex;') >= 0)
        res += 'display: -webkit-box;display: -webkit-flex;';
    res = res.replace(/transform:(.+?);/g, (s, $1) => `${s}-webkit-transform:${$1};`);
    res = res.replace(/flex-direction:(.+?);/g, (s, $1) => `${s}-webkit-flex-direction:${$1};`);
    return res;
}
function setTransform(el, val) {
    el.style.webkitTransform = val;
    el.style.transform = val;
}
function serializeParams(params) {
    if (!params) {
        return '';
    }
    return Object.keys(params)
        .map(key => (`${encodeURIComponent(key)}=${typeof (params[key]) === 'object'
        ? encodeURIComponent(JSON.stringify(params[key]))
        : encodeURIComponent(params[key])}`))
        .join('&');
}
function temporarilyNotSupport(apiName) {
    return () => {
        const errMsg = `暂时不支持 API ${apiName}`;
        if (process.env.NODE_ENV !== 'production') {
            console.error(errMsg);
            return Promise.reject({
                errMsg
            });
        }
        else {
            console.warn(errMsg);
            return Promise.resolve({
                errMsg
            });
        }
    };
}
function weixinCorpSupport(apiName) {
    return () => {
        const errMsg = `h5端当前仅在微信公众号JS-SDK环境下支持此 API ${apiName}`;
        if (process.env.NODE_ENV !== 'production') {
            console.error(errMsg);
            return Promise.reject({
                errMsg
            });
        }
        else {
            console.warn(errMsg);
            return Promise.resolve({
                errMsg
            });
        }
    };
}
function permanentlyNotSupport(apiName) {
    return () => {
        const errMsg = `不支持 API ${apiName}`;
        if (process.env.NODE_ENV !== 'production') {
            console.error(errMsg);
            return Promise.reject({
                errMsg
            });
        }
        else {
            console.warn(errMsg);
            return Promise.resolve({
                errMsg
            });
        }
    };
}
function processOpenApi({ name, defaultOptions, standardMethod, formatOptions = options => options, formatResult = res => res }) {
    const notSupported = weixinCorpSupport(name);
    return (options = {}) => {
        var _a;
        // @ts-ignore
        const targetApi = (_a = window === null || window === void 0 ? void 0 : window.wx) === null || _a === void 0 ? void 0 : _a[name];
        const opts = formatOptions(Object.assign({}, defaultOptions, options));
        if (typeof targetApi === 'function') {
            return new Promise((resolve, reject) => {
                ['fail', 'success', 'complete'].forEach(k => {
                    opts[k] = preRef => {
                        const res = formatResult(preRef);
                        options[k] && options[k](res);
                        if (k === 'success') {
                            resolve(res);
                        }
                        else if (k === 'fail') {
                            reject(res);
                        }
                    };
                    return targetApi(opts);
                });
            });
        }
        else if (typeof standardMethod === 'function') {
            return standardMethod(opts);
        }
        else {
            return notSupported();
        }
    };
}

// 广告
const createRewardedVideoAd = temporarilyNotSupport('createRewardedVideoAd');
const createInterstitialAd = temporarilyNotSupport('createInterstitialAd');

// 人脸识别
const stopFaceDetect = temporarilyNotSupport('stopFaceDetect');
const initFaceDetect = temporarilyNotSupport('initFaceDetect');
const faceDetect = temporarilyNotSupport('faceDetect');

// 判断支持版本
const isVKSupport = temporarilyNotSupport('isVKSupport');
// 视觉算法
const createVKSession = temporarilyNotSupport('createVKSession');

class MethodHandler {
    constructor({ name, success, fail, complete }) {
        this.methodName = name;
        this.__success = success;
        this.__fail = fail;
        this.__complete = complete;
    }
    success(res = {}, resolve = Promise.resolve.bind(Promise)) {
        if (!res.errMsg) {
            res.errMsg = `${this.methodName}:ok`;
        }
        typeof this.__success === 'function' && this.__success(res);
        typeof this.__complete === 'function' && this.__complete(res);
        return resolve(res);
    }
    fail(res = {}, reject = Promise.reject.bind(Promise)) {
        if (!res.errMsg) {
            res.errMsg = `${this.methodName}:fail`;
        }
        else {
            res.errMsg = `${this.methodName}:fail ${res.errMsg}`;
        }
        console.error(res.errMsg);
        typeof this.__fail === 'function' && this.__fail(res);
        typeof this.__complete === 'function' && this.__complete(res);
        return reject(res);
    }
}
class CallbackManager {
    constructor() {
        this.callbacks = [];
        /**
         * 添加回调
         * @param {{ callback: function, ctx: any } | function} opt
         */
        this.add = (opt) => {
            if (opt)
                this.callbacks.push(opt);
        };
        /**
         * 移除回调
         * @param {{ callback: function, ctx: any } | function} opt
         */
        this.remove = (opt) => {
            if (opt) {
                let pos = -1;
                this.callbacks.forEach((callback, k) => {
                    if (callback === opt) {
                        pos = k;
                    }
                });
                if (pos > -1) {
                    this.callbacks.splice(pos, 1);
                }
            }
        };
        /**
         * 获取回调函数数量
         * @return {number}
         */
        this.count = () => {
            return this.callbacks.length;
        };
        /**
         * 触发回调
         * @param  {...any} args 回调的调用参数
         */
        this.trigger = (...args) => {
            this.callbacks.forEach(opt => {
                if (typeof opt === 'function') {
                    opt(...args);
                }
                else {
                    const { callback, ctx } = opt;
                    typeof callback === 'function' && callback.call(ctx, ...args);
                }
            });
        };
    }
}

/** 跳转系统蓝牙设置页 */
const openSystemBluetoothSetting = temporarilyNotSupport('openSystemBluetoothSetting');
/** 跳转系统微信授权管理页 */
const openAppAuthorizeSetting = temporarilyNotSupport('openAppAuthorizeSetting');
/** 获取窗口信息 */
const getWindowInfo = () => {
    const info = {
        /** 设备像素比 */
        pixelRatio: window.devicePixelRatio,
        /** 屏幕宽度，单位px */
        screenWidth: window.screen.width,
        /** 屏幕高度，单位px */
        screenHeight: window.screen.height,
        /** 可使用窗口宽度，单位px */
        windowWidth: document.documentElement.clientWidth,
        /** 可使用窗口高度，单位px */
        windowHeight: document.documentElement.clientHeight,
        /** 状态栏的高度，单位px */
        statusBarHeight: NaN,
        /** 在竖屏正方向下的安全区域 */
        safeArea: {
            bottom: 0,
            height: 0,
            left: 0,
            right: 0,
            top: 0,
            width: 0
        }
    };
    return info;
};
/** 获取设备设置 */
const getSystemSetting = () => {
    const isLandscape = window.screen.width >= window.screen.height;
    const info = {
        /** 蓝牙的系统开关 */
        bluetoothEnabled: false,
        /** 地理位置的系统开关 */
        locationEnabled: false,
        /** Wi-Fi 的系统开关 */
        wifiEnabled: false,
        /** 设备方向 */
        deviceOrientation: isLandscape ? 'landscape' : 'portrait'
    };
    return info;
};
/** 获取设备设置 */
const getDeviceInfo = () => {
    const md = new MobileDetect__default["default"](navigator.userAgent);
    const info = {
        /** 应用二进制接口类型（仅 Android 支持） */
        abi: '',
        /** 设备性能等级（仅Android小游戏）。取值为：-2 或 0（该设备无法运行小游戏），-1（性能未知），>=1（设备性能值，该值越高，设备性能越好，目前最高不到50） */
        benchmarkLevel: -1,
        /** 设备品牌 */
        brand: md.mobile() || '',
        /** 设备型号 */
        model: md.mobile() || '',
        /** 操作系统及版本 */
        system: md.os(),
        /** 客户端平台 */
        platform: navigator.platform
    };
    return info;
};
/** 获取微信APP基础信息 */
const getAppBaseInfo = () => {
    var _a;
    let isDarkMode = false;
    if ((_a = window.matchMedia) === null || _a === void 0 ? void 0 : _a.call(window, '(prefers-color-scheme: dark)').matches) {
        isDarkMode = true;
    }
    const info = {
        /** 客户端基础库版本 */
        SDKVersion: '',
        /** 是否已打开调试。可通过右上角菜单或 [Taro.setEnableDebug](/docs/apis/base/debug/setEnableDebug) 打开调试。 */
        enableDebug: process.env.NODE_ENV === 'development',
        /** 当前小程序运行的宿主环境 */
        // host: { appId: '' },
        /** 微信设置的语言 */
        language: navigator.language,
        /** 微信版本号 */
        version: '',
        /** 系统当前主题，取值为light或dark，全局配置"darkmode":true时才能获取，否则为 undefined （不支持小游戏） */
        theme: isDarkMode ? 'dark' : 'light'
    };
    return info;
};
/** 获取微信APP授权设置 */
const getAppAuthorizeSetting = () => {
    const info = {
        /** 允许微信使用相册的开关（仅 iOS 有效） */
        albumAuthorized: 'not determined',
        /** 允许微信使用蓝牙的开关（仅 iOS 有效） */
        bluetoothAuthorized: 'not determined',
        /** 允许微信使用摄像头的开关 */
        cameraAuthorized: 'not determined',
        /** 允许微信使用定位的开关 */
        locationAuthorized: 'not determined',
        /** 定位准确度。true 表示模糊定位，false 表示精确定位（仅 iOS 有效） */
        locationReducedAccuracy: false,
        /** 允许微信使用麦克风的开关 */
        microphoneAuthorized: 'not determined',
        /** 允许微信通知的开关 */
        notificationAuthorized: 'not determined',
        /** 允许微信通知带有提醒的开关（仅 iOS 有效） */
        notificationAlertAuthorized: 'not determined',
        /** 允许微信通知带有标记的开关（仅 iOS 有效） */
        notificationBadgeAuthorized: 'not determined',
        /** 允许微信通知带有声音的开关（仅 iOS 有效） */
        notificationSoundAuthorized: 'not determined',
        /** 允许微信使用日历的开关 */
        phoneCalendarAuthorized: 'not determined'
    };
    return info;
};
/** 获取设备设置 */
const getSystemInfoSync = () => {
    const windowInfo = getWindowInfo();
    const systemSetting = getSystemSetting();
    const deviceInfo = getDeviceInfo();
    const appBaseInfo = getAppBaseInfo();
    const appAuthorizeSetting = getAppAuthorizeSetting();
    delete deviceInfo.abi;
    const info = {
        ...windowInfo,
        ...systemSetting,
        ...deviceInfo,
        ...appBaseInfo,
        /** 用户字体大小（单位px）。以微信客户端「我-设置-通用-字体大小」中的设置为准 */
        fontSizeSetting: NaN,
        /** 允许微信使用相册的开关（仅 iOS 有效） */
        albumAuthorized: appAuthorizeSetting.albumAuthorized === 'authorized',
        /** 允许微信使用摄像头的开关 */
        cameraAuthorized: appAuthorizeSetting.cameraAuthorized === 'authorized',
        /** 允许微信使用定位的开关 */
        locationAuthorized: appAuthorizeSetting.locationAuthorized === 'authorized',
        /** 允许微信使用麦克风的开关 */
        microphoneAuthorized: appAuthorizeSetting.microphoneAuthorized === 'authorized',
        /** 允许微信通知的开关 */
        notificationAuthorized: appAuthorizeSetting.notificationAuthorized === 'authorized',
        /** 允许微信通知带有提醒的开关（仅 iOS 有效） */
        notificationAlertAuthorized: appAuthorizeSetting.notificationAlertAuthorized === 'authorized',
        /** 允许微信通知带有标记的开关（仅 iOS 有效） */
        notificationBadgeAuthorized: appAuthorizeSetting.notificationBadgeAuthorized === 'authorized',
        /** 允许微信通知带有声音的开关（仅 iOS 有效） */
        notificationSoundAuthorized: appAuthorizeSetting.notificationSoundAuthorized === 'authorized',
        /** 允许微信使用日历的开关 */
        phoneCalendarAuthorized: appAuthorizeSetting.phoneCalendarAuthorized === 'authorized',
        /** `true` 表示模糊定位，`false` 表示精确定位，仅 iOS 支持 */
        locationReducedAccuracy: appAuthorizeSetting.locationReducedAccuracy,
        /** 小程序当前运行环境 */
        environment: ''
    };
    return info;
};
/** 获取系统信息 */
const getSystemInfoAsync = async (options = {}) => {
    const { success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'getSystemInfoAsync', success, fail, complete });
    try {
        const info = await getSystemInfoSync();
        return handle.success(info);
    }
    catch (error) {
        return handle.fail({
            errMsg: error
        });
    }
};
/** 获取系统信息 */
const getSystemInfo = async (options = {}) => {
    const { success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'getSystemInfo', success, fail, complete });
    try {
        const info = await getSystemInfoSync();
        return handle.success(info);
    }
    catch (error) {
        return handle.fail({
            errMsg: error
        });
    }
};

// 更新
const updateWeChatApp = temporarilyNotSupport('updateWeChatApp');
const getUpdateManager = temporarilyNotSupport('getUpdateManager');

// 生命周期
const getLaunchOptionsSync = temporarilyNotSupport('getLaunchOptionsSync');
const getEnterOptionsSync = temporarilyNotSupport('getEnterOptionsSync');

// 应用级事件
const onUnhandledRejection = temporarilyNotSupport('onUnhandledRejection');
const onThemeChange = temporarilyNotSupport('onThemeChange');
const onPageNotFound = temporarilyNotSupport('onPageNotFound');
const onError = temporarilyNotSupport('onError');
const onAudioInterruptionEnd = temporarilyNotSupport('onAudioInterruptionEnd');
const onAudioInterruptionBegin = temporarilyNotSupport('onAudioInterruptionBegin');
const onAppShow = temporarilyNotSupport('onAppShow');
const onAppHide = temporarilyNotSupport('onAppHide');
const offUnhandledRejection = temporarilyNotSupport('offUnhandledRejection');
const offThemeChange = temporarilyNotSupport('offThemeChange');
const offPageNotFound = temporarilyNotSupport('offPageNotFound');
const offError = temporarilyNotSupport('offError');
const offAudioInterruptionEnd = temporarilyNotSupport('offAudioInterruptionEnd');
const offAudioInterruptionBegin = temporarilyNotSupport('offAudioInterruptionBegin');
const offAppShow = temporarilyNotSupport('offAppShow');
const offAppHide = temporarilyNotSupport('offAppHide');

const setEnableDebug = temporarilyNotSupport('setEnableDebug');
const getRealtimeLogManager = temporarilyNotSupport('getRealtimeLogManager');
const getLogManager = temporarilyNotSupport('getLogManager');

// 性能
const reportPerformance = temporarilyNotSupport('reportPerformance');
const getPerformance = temporarilyNotSupport('getPerformance');

// 加密
const getUserCryptoManager = temporarilyNotSupport('getUserCryptoManager');

// TODO env 环境变量
const canIUse = temporarilyNotSupport('canIUse');
function arrayBufferToBase64(arrayBuffer) {
    return base64Js.fromByteArray(arrayBuffer);
}
function base64ToArrayBuffer(base64) {
    return base64Js.toByteArray(base64);
}

const TextBaseLineMap = {
    top: 'top',
    bottom: 'bottom',
    middle: 'middle',
    normal: 'alphabetic'
};
class CanvasContext {
    constructor(canvas, ctx) {
        this.actions = [];
        this.canvas = canvas;
        this.ctx = ctx;
    }
    set ctx(e) {
        this.__raw__ = e;
    }
    get ctx() {
        return this.__raw__ || {};
    }
    emptyActions() {
        this.actions.length = 0;
    }
    enqueueActions(func, ...args) {
        this.actions.push({
            func,
            args
        });
    }
    set fillStyle(e) { this.enqueueActions(() => { this.ctx.fillStyle = e; }); }
    get fillStyle() { return this.ctx.fillStyle; }
    set font(e) { this.ctx.font = e; }
    get font() { return this.ctx.font; }
    set globalAlpha(e) { this.enqueueActions(() => { this.ctx.globalAlpha = e; }); }
    get globalAlpha() { return this.ctx.globalAlpha; }
    set globalCompositeOperation(e) { this.enqueueActions(() => { this.ctx.globalCompositeOperation = e; }); }
    get globalCompositeOperation() { return this.ctx.globalCompositeOperation; }
    set lineCap(e) { this.enqueueActions(() => { this.ctx.lineCap = e; }); }
    get lineCap() { return this.ctx.lineCap; }
    set lineDashOffset(e) { this.enqueueActions(() => { this.ctx.lineDashOffset = e; }); }
    get lineDashOffset() { return this.ctx.lineDashOffset; }
    set lineJoin(e) { this.enqueueActions(() => { this.ctx.lineJoin = e; }); }
    get lineJoin() { return this.ctx.lineJoin; }
    set lineWidth(e) { this.enqueueActions(() => { this.ctx.lineWidth = e; }); }
    get lineWidth() { return this.ctx.lineWidth; }
    set miterLimit(e) { this.enqueueActions(() => { this.ctx.miterLimit = e; }); }
    get miterLimit() { return this.ctx.miterLimit; }
    set shadowBlur(e) { this.enqueueActions(() => { this.ctx.shadowBlur = e; }); }
    get shadowBlur() { return this.ctx.shadowBlur; }
    set shadowColor(e) { this.enqueueActions(() => { this.ctx.shadowColor = e; }); }
    get shadowColor() { return this.ctx.shadowColor; }
    set shadowOffsetX(e) { this.enqueueActions(() => { this.ctx.shadowOffsetX = e; }); }
    get shadowOffsetX() { return this.ctx.shadowOffsetX; }
    set shadowOffsetY(e) { this.enqueueActions(() => { this.ctx.shadowOffsetY = e; }); }
    get shadowOffsetY() { return this.ctx.shadowOffsetY; }
    set strokeStyle(e) { this.enqueueActions(() => { this.ctx.strokeStyle = e; }); }
    get strokeStyle() { return this.ctx.strokeStyle; }
    /** 小程序文档中不包括 ↓↓↓ */
    set textAlign(e) { this.ctx.textAlign = e; }
    get textAlign() { return this.ctx.textAlign; }
    set textBaseline(e) { this.ctx.textBaseline = e; }
    get textBaseline() { return this.ctx.textBaseline; }
    set direction(e) { this.ctx.direction = e; }
    get direction() { return this.ctx.direction; }
    set imageSmoothingEnabled(e) { this.enqueueActions(() => { this.ctx.imageSmoothingEnabled = e; }); }
    get imageSmoothingEnabled() { return this.ctx.imageSmoothingEnabled; }
    set imageSmoothingQuality(e) { this.enqueueActions(() => { this.ctx.imageSmoothingQuality = e; }); }
    get imageSmoothingQuality() { return this.ctx.imageSmoothingQuality; }
    set filter(e) { this.enqueueActions(() => { this.ctx.filter = e; }); }
    get filter() { return this.ctx.filter; }
    /** 小程序文档中不包括 ↑↑↑ */
    arc(...args) { return this.enqueueActions(this.ctx.arc, ...args); }
    arcTo(...args) { return this.enqueueActions(this.ctx.arcTo, ...args); }
    beginPath(...args) { return this.enqueueActions(this.ctx.beginPath, ...args); }
    bezierCurveTo(...args) { return this.enqueueActions(this.ctx.bezierCurveTo, ...args); }
    clearRect(...args) { return this.enqueueActions(this.ctx.clearRect, ...args); }
    clip(...args) { return this.enqueueActions(this.ctx.clip, ...args); }
    closePath(...args) { return this.enqueueActions(this.ctx.closePath, ...args); }
    createPattern(image, repetition) {
        return this.createPattern(image, repetition);
    }
    /**
     * 将之前在绘图上下文中的描述（路径、变形、样式）画到 canvas 中。
     * @todo 每次 draw 都会读取 width 和 height
     */
    async draw(reserve, callback) {
        try {
            if (!reserve) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
            // 部分 action 是异步的
            for (const { func, args } of this.actions) {
                await func.apply(this.ctx, args);
            }
            this.emptyActions();
            callback && callback();
        }
        catch (e) {
            /* eslint-disable no-throw-literal */
            throw {
                errMsg: e.message
            };
        }
    }
    drawImage(imageResource, ...extra) {
        this.enqueueActions(() => {
            // 需要转换为 Image
            if (typeof imageResource === 'string') {
                const img = new Image();
                img.src = imageResource;
                return new Promise((resolve, reject) => {
                    img.onload = () => {
                        this.ctx.drawImage(img, ...extra);
                        resolve();
                    };
                    img.onerror = reject;
                });
            }
            this.ctx.drawImage(imageResource, ...extra);
        });
    }
    fill(...args) { return this.enqueueActions(this.ctx.fill, ...args); }
    fillRect(...args) { return this.enqueueActions(this.ctx.fillRect, ...args); }
    fillText(...args) { return this.enqueueActions(this.ctx.fillText, ...args); }
    lineTo(...args) { return this.enqueueActions(this.ctx.lineTo, ...args); }
    moveTo(...args) { return this.enqueueActions(this.ctx.moveTo, ...args); }
    quadraticCurveTo(...args) { return this.enqueueActions(this.ctx.quadraticCurveTo, ...args); }
    rect(...args) { return this.enqueueActions(this.ctx.rect, ...args); }
    restore(...args) { return this.enqueueActions(this.ctx.restore, ...args); }
    rotate(...args) { return this.enqueueActions(this.ctx.rotate, ...args); }
    save(...args) { return this.enqueueActions(this.ctx.save, ...args); }
    scale(...args) { return this.enqueueActions(this.ctx.scale, ...args); }
    setFillStyle(color) {
        this.enqueueActions(() => { this.ctx.fillStyle = color; });
    }
    setFontSize(fontSize) {
        this.font = `${fontSize}px`;
    }
    setGlobalAlpha(alpha) {
        this.globalAlpha = alpha;
    }
    setLineCap(lineCap) {
        this.lineCap = lineCap;
    }
    setLineDash(pattern, offset) {
        this.enqueueActions(() => {
            this.ctx.setLineDash(pattern);
            this.ctx.lineDashOffset = offset;
        });
    }
    setLineJoin(lineJoin) {
        this.lineJoin = lineJoin;
    }
    setLineWidth(lineWidth) {
        this.lineWidth = lineWidth;
    }
    setMiterLimit(miterLimit) {
        this.miterLimit = miterLimit;
    }
    setShadow(offsetX, offsetY, blur, color) {
        this.enqueueActions(() => {
            this.ctx.shadowOffsetX = offsetX;
            this.ctx.shadowOffsetY = offsetY;
            this.ctx.shadowColor = color;
            this.ctx.shadowBlur = blur;
        });
    }
    setStrokeStyle(color) {
        this.enqueueActions(() => { this.ctx.strokeStyle = color; });
    }
    setTextAlign(align) {
        this.textAlign = align;
    }
    setTextBaseline(textBaseline) {
        this.textBaseline = TextBaseLineMap[textBaseline] || 'alphabetic';
    }
    setTransform(...args) { return this.enqueueActions(this.ctx.setTransform, ...args); }
    stroke(...args) { return this.enqueueActions(this.ctx.stroke, ...args); }
    strokeRect(...args) { return this.enqueueActions(this.ctx.strokeRect, ...args); }
    strokeText(...args) { return this.enqueueActions(this.ctx.strokeText, ...args); }
    transform(...args) { return this.enqueueActions(this.ctx.transform, ...args); }
    translate(...args) { return this.enqueueActions(this.ctx.translate, ...args); }
    measureText(text) {
        return this.ctx.measureText(text);
    }
    createCircularGradient(x, y, r) {
        const radialGradient = this.ctx.createRadialGradient(x, y, 0, x, y, r);
        return radialGradient;
    }
    createLinearGradient(x0, y0, x1, y1) {
        return this.createLinearGradient(x0, y0, x1, y1);
    }
}

/**
 * 创建 canvas 的绘图上下文 CanvasContext 对象
 */
const createCanvasContext = (canvasId, inst) => {
    const el = findDOM(inst);
    const canvas = el === null || el === void 0 ? void 0 : el.querySelector(`canvas[canvas-id="${canvasId}"]`);
    const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext('2d');
    const context = new CanvasContext(canvas, ctx);
    if (!ctx)
        return context;
    context.canvas = canvas;
    context.ctx = ctx;
    return context;
};

/**
 * 把当前画布指定区域的内容导出生成指定大小的图片。在 draw() 回调里调用该方法才能保证图片导出成功。
 * @todo 暂未支持尺寸相关功能
 */
const canvasToTempFilePath = ({ canvasId, fileType, quality, success, fail, complete }, inst) => {
    const handle = new MethodHandler({ name: 'canvasToTempFilePath', success, fail, complete });
    const el = findDOM(inst);
    const canvas = el === null || el === void 0 ? void 0 : el.querySelector(`canvas[canvas-id="${canvasId}"]`);
    try {
        const dataURL = canvas === null || canvas === void 0 ? void 0 : canvas.toDataURL(`image/${fileType || 'png'}`, quality);
        return handle.success({
            tempFilePath: dataURL
        });
    }
    catch (e) {
        return handle.fail({
            errMsg: e.message
        });
    }
};

/**
 * 将像素数据绘制到画布。在自定义组件下，第二个参数传入自定义组件实例 this，以操作组件内 <canvas> 组件
 * @todo 暂未支持尺寸相关功能
 */
const canvasPutImageData = ({ canvasId, data, x, y, success, fail, complete }, inst) => {
    const handle = new MethodHandler({ name: 'canvasPutImageData', success, fail, complete });
    const el = findDOM(inst);
    const canvas = el === null || el === void 0 ? void 0 : el.querySelector(`canvas[canvas-id="${canvasId}"]`);
    try {
        const ctx = canvas.getContext('2d');
        // TODO Uint8ClampedArray => ImageData
        ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(data, x, y);
        return handle.success();
    }
    catch (e) {
        return handle.fail({
            errMsg: e.message
        });
    }
};

/**
 * 获取 canvas 区域隐含的像素数据。
 */
const canvasGetImageData = ({ canvasId, success, fail, complete, x, y, width, height }, inst) => {
    const handle = new MethodHandler({ name: 'canvasGetImageData', success, fail, complete });
    const el = findDOM(inst);
    const canvas = el === null || el === void 0 ? void 0 : el.querySelector(`canvas[canvas-id="${canvasId}"]`);
    try {
        const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext('2d');
        // TODO ImageData => Uint8ClampedArray
        const data = ctx === null || ctx === void 0 ? void 0 : ctx.getImageData(x, y, width, height);
        return handle.success({
            width,
            height,
            data
        });
    }
    catch (e) {
        return handle.fail({
            errMsg: e.message
        });
    }
};

// 画布
/** 创建离屏 canvas 实例 */
const createOffscreenCanvas = temporarilyNotSupport('createOffscreenCanvas');

class cloud {
    constructor() {
        this.init = temporarilyNotSupport('cloud.init');
        this.CloudID = temporarilyNotSupport('cloud.CloudID');
        // @ts-ignore
        this.callFunction = temporarilyNotSupport('cloud.callFunction');
        // @ts-ignore
        this.uploadFile = temporarilyNotSupport('cloud.uploadFile');
        // @ts-ignore
        this.downloadFile = temporarilyNotSupport('cloud.downloadFile');
        // @ts-ignore
        this.getTempFileURL = temporarilyNotSupport('cloud.getTempFileURL');
        // @ts-ignore
        this.deleteFile = temporarilyNotSupport('cloud.deleteFile');
        // @ts-ignore
        this.database = temporarilyNotSupport('cloud.database');
        // @ts-ignore
        this.callContainer = temporarilyNotSupport('cloud.callContainer');
    }
}

const reportMonitor = temporarilyNotSupport('reportMonitor');
const reportAnalytics = temporarilyNotSupport('reportAnalytics');
const reportEvent = temporarilyNotSupport('reportEvent');
const getExptInfoSync = temporarilyNotSupport('getExptInfoSync');

const callbackManager$3 = new CallbackManager();
let devicemotionListener;
/**
 * 停止监听加速度数据。
 */
const stopAccelerometer = ({ success, fail, complete } = {}) => {
    const res = {};
    const handle = new MethodHandler({ name: 'stopAccelerometer', success, fail, complete });
    try {
        window.removeEventListener('devicemotion', devicemotionListener, true);
        return handle.success(res);
    }
    catch (e) {
        res.errMsg = e.message;
        return handle.fail(res);
    }
};
const INTERVAL_MAP$1 = {
    game: {
        interval: 20,
        frequency: 50
    },
    ui: {
        interval: 60,
        frequency: 16.67
    },
    normal: {
        interval: 200,
        frequency: 5
    }
};
/**
 * 开始监听加速度数据。
 */
const startAccelerometer = ({ interval = 'normal', success, fail, complete } = {}) => {
    const handle = new MethodHandler({ name: 'startAccelerometer', success, fail, complete });
    try {
        if (window.DeviceMotionEvent) {
            const intervalObj = INTERVAL_MAP$1[interval];
            if (devicemotionListener) {
                stopAccelerometer();
            }
            devicemotionListener = throttle((evt) => {
                var _a, _b, _c;
                callbackManager$3.trigger({
                    x: ((_a = evt.acceleration) === null || _a === void 0 ? void 0 : _a.x) || 0,
                    y: ((_b = evt.acceleration) === null || _b === void 0 ? void 0 : _b.y) || 0,
                    z: ((_c = evt.acceleration) === null || _c === void 0 ? void 0 : _c.z) || 0
                });
            }, intervalObj.interval);
            window.addEventListener('devicemotion', devicemotionListener, true);
        }
        else {
            throw new Error('accelerometer is not supported');
        }
        return handle.success();
    }
    catch (e) {
        return handle.fail({ errMsg: e.message });
    }
};
/**
 * 监听加速度数据事件。频率根据 Taro.startAccelerometer() 的 interval 参数。可使用 Taro.stopAccelerometer() 停止监听。
 */
const onAccelerometerChange = callback => {
    callbackManager$3.add(callback);
};
/**
 * 取消监听加速度数据事件，参数为空，则取消所有的事件监听
 */
const offAccelerometerChange = callback => {
    callbackManager$3.remove(callback);
};

// 无障碍
const checkIsOpenAccessibility = temporarilyNotSupport('checkIsOpenAccessibility');

// 电量
const getBatteryInfoSync = temporarilyNotSupport('getBatteryInfoSync');
const getBatteryInfo = async ({ success, fail, complete } = {}) => {
    var _a;
    const handle = new MethodHandler({ name: 'getBatteryInfo', success, fail, complete });
    try {
        // @ts-ignore
        const battery = await ((_a = navigator.getBattery) === null || _a === void 0 ? void 0 : _a.call(navigator));
        return handle.success({
            isCharging: battery.charging,
            level: Number(battery.level || 0) * 100
        });
    }
    catch (error) {
        return handle.fail({
            errMsg: (error === null || error === void 0 ? void 0 : error.message) || error
        });
    }
};

// 蓝牙-通用
const stopBluetoothDevicesDiscovery = temporarilyNotSupport('stopBluetoothDevicesDiscovery');
const startBluetoothDevicesDiscovery = temporarilyNotSupport('startBluetoothDevicesDiscovery');
const openBluetoothAdapter = temporarilyNotSupport('openBluetoothAdapter');
const onBluetoothDeviceFound = temporarilyNotSupport('onBluetoothDeviceFound');
const onBluetoothAdapterStateChange = temporarilyNotSupport('onBluetoothAdapterStateChange');
const offBluetoothDeviceFound = temporarilyNotSupport('offBluetoothDeviceFound');
const offBluetoothAdapterStateChange = temporarilyNotSupport('offBluetoothAdapterStateChange');
const makeBluetoothPair = temporarilyNotSupport('makeBluetoothPair');
const isBluetoothDevicePaired = temporarilyNotSupport('isBluetoothDevicePaired');
const getConnectedBluetoothDevices = temporarilyNotSupport('getConnectedBluetoothDevices');
const getBluetoothDevices = temporarilyNotSupport('getBluetoothDevices');
const getBluetoothAdapterState = temporarilyNotSupport('getBluetoothAdapterState');
const closeBluetoothAdapter = temporarilyNotSupport('closeBluetoothAdapter');

// 蓝牙-低功耗中心设备
const writeBLECharacteristicValue = temporarilyNotSupport('writeBLECharacteristicValue');
const setBLEMTU = temporarilyNotSupport('setBLEMTU');
const readBLECharacteristicValue = temporarilyNotSupport('readBLECharacteristicValue');
const onBLEMTUChange = temporarilyNotSupport('onBLEMTUChange');
const onBLEConnectionStateChange = temporarilyNotSupport('onBLEConnectionStateChange');
const onBLECharacteristicValueChange = temporarilyNotSupport('onBLECharacteristicValueChange');
const offBLEMTUChange = temporarilyNotSupport('offBLEMTUChange');
const offBLEConnectionStateChange = temporarilyNotSupport('offBLEConnectionStateChange');
const offBLECharacteristicValueChange = temporarilyNotSupport('offBLECharacteristicValueChange');
const notifyBLECharacteristicValueChange = temporarilyNotSupport('notifyBLECharacteristicValueChange');
const getBLEMTU = temporarilyNotSupport('getBLEMTU');
const getBLEDeviceServices = temporarilyNotSupport('getBLEDeviceServices');
const getBLEDeviceRSSI = temporarilyNotSupport('getBLEDeviceRSSI');
const getBLEDeviceCharacteristics = temporarilyNotSupport('getBLEDeviceCharacteristics');
const createBLEConnection = temporarilyNotSupport('createBLEConnection');
const closeBLEConnection = temporarilyNotSupport('closeBLEConnection');

// 蓝牙-低功耗外围设备
const onBLEPeripheralConnectionStateChanged = temporarilyNotSupport('onBLEPeripheralConnectionStateChanged');
const offBLEPeripheralConnectionStateChanged = temporarilyNotSupport('offBLEPeripheralConnectionStateChanged');
const createBLEPeripheralServer = temporarilyNotSupport('createBLEPeripheralServer');

// 日历
const addPhoneRepeatCalendar = temporarilyNotSupport('addPhoneRepeatCalendar');
const addPhoneCalendar = temporarilyNotSupport('addPhoneCalendar');

// 周期性更新
const setBackgroundFetchToken = temporarilyNotSupport('setBackgroundFetchToken');
const onBackgroundFetchData = temporarilyNotSupport('onBackgroundFetchData');
const getBackgroundFetchToken = temporarilyNotSupport('getBackgroundFetchToken');
const getBackgroundFetchData = temporarilyNotSupport('getBackgroundFetchData');

function getItem(key) {
    let item;
    try {
        item = JSON.parse(localStorage.getItem(key) || '');
    }
    catch (e) { }
    // 只返回使用 Taro.setStorage API 存储的数据
    if (item && typeof item === 'object' && item.hasOwnProperty('data')) {
        return { result: true, data: item.data };
    }
    else {
        return { result: false };
    }
}
// 数据缓存
const setStorageSync = (key, data = '') => {
    if (typeof key !== 'string') {
        console.error(getParameterError({
            name: 'setStorage',
            correct: 'String',
            wrong: key
        }));
        return;
    }
    const type = typeof data;
    let obj = {};
    if (type === 'symbol') {
        obj = { data: '' };
    }
    else {
        obj = { data };
    }
    localStorage.setItem(key, JSON.stringify(obj));
};
const setStorage = (options) => {
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `setStorage:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { key, data, success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'setStorage', success, fail, complete });
    if (typeof key !== 'string') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'key',
                correct: 'String',
                wrong: key
            })
        });
    }
    setStorageSync(key, data);
    return handle.success();
};
const revokeBufferURL = temporarilyNotSupport('revokeBufferURL');
const removeStorageSync = (key) => {
    if (typeof key !== 'string') {
        console.error(getParameterError({
            name: 'removeStorage',
            correct: 'String',
            wrong: key
        }));
        return;
    }
    localStorage.removeItem(key);
};
const removeStorage = (options) => {
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `removeStorage:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { key, success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'removeStorage', success, fail, complete });
    if (typeof key !== 'string') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'key',
                correct: 'String',
                wrong: key
            })
        });
    }
    removeStorageSync(key);
    return handle.success();
};
const getStorageSync = (key) => {
    if (typeof key !== 'string') {
        console.error(getParameterError({
            name: 'getStorageSync',
            correct: 'String',
            wrong: key
        }));
        return;
    }
    const res = getItem(key);
    if (res.result)
        return res.data;
    return '';
};
const getStorageInfoSync = () => {
    const res = {
        keys: Object.keys(localStorage),
        limitSize: NaN,
        currentSize: NaN
    };
    return res;
};
const getStorageInfo = ({ success, fail, complete } = {}) => {
    const handle = new MethodHandler({ name: 'getStorageInfo', success, fail, complete });
    return handle.success(getStorageInfoSync());
};
const getStorage = (options) => {
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `getStorage:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { key, success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'getStorage', success, fail, complete });
    if (typeof key !== 'string') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'key',
                correct: 'String',
                wrong: key
            })
        });
    }
    const { result, data } = getItem(key);
    if (result) {
        return handle.success({ data });
    }
    else {
        return handle.fail({
            errMsg: 'data not found'
        });
    }
};
const createBufferURL = temporarilyNotSupport('createBufferURL');
const clearStorageSync = () => {
    localStorage.clear();
};
const clearStorage = ({ success, fail, complete } = {}) => {
    const handle = new MethodHandler({ name: 'clearStorage', success, fail, complete });
    clearStorageSync();
    return handle.success();
};

/**
 * 剪贴板部分的api参考了Chameleon项目的实现：
 *
 * setClipboardData: https://github.com/chameleon-team/chameleon-api/tree/master/src/interfaces/setClipBoardData
 * getClipboardData: https://github.com/chameleon-team/chameleon-api/tree/master/src/interfaces/getClipBoardData
 */
const CLIPBOARD_STORAGE_NAME = 'taro_clipboard';
document.addEventListener('copy', () => {
    var _a;
    setStorage({
        key: CLIPBOARD_STORAGE_NAME,
        data: (_a = window.getSelection()) === null || _a === void 0 ? void 0 : _a.toString()
    }).catch(e => {
        console.error(e);
    });
});
/**
 * 设置系统剪贴板的内容
 */
const setClipboardData = async ({ data, success, fail, complete }) => {
    const handle = new MethodHandler({ name: 'setClipboardData', success, fail, complete });
    try {
        setStorageSync(CLIPBOARD_STORAGE_NAME, data);
        /**
         * 已于 iPhone 6s Plus iOS 13.1.3 上的 Safari 测试通过
         * iOS < 10 的系统可能无法使用编程方式访问剪贴板，参考：
         * https://stackoverflow.com/questions/34045777/copy-to-clipboard-using-javascript-in-ios/34046084
         */
        if (typeof document.execCommand === 'function') {
            const textarea = document.createElement('textarea');
            textarea.readOnly = true;
            textarea.value = data;
            textarea.style.position = 'absolute';
            textarea.style.width = '100px';
            textarea.style.left = '-10000px';
            document.body.appendChild(textarea);
            textarea.select();
            textarea.setSelectionRange(0, textarea.value.length);
            document.execCommand('copy');
            document.body.removeChild(textarea);
        }
        else {
            throw new Error('Unsupported Function: \'document.execCommand\'.');
        }
        return handle.success();
    }
    catch (e) {
        return handle.fail({ errMsg: e.message });
    }
};
/**
 * 获取系统剪贴板的内容
 */
const getClipboardData = async ({ success, fail, complete } = {}) => {
    const handle = new MethodHandler({ name: 'getClipboardData', success, fail, complete });
    try {
        const data = getStorageSync(CLIPBOARD_STORAGE_NAME);
        return handle.success({ data });
    }
    catch (e) {
        return handle.fail({ errMsg: e.message });
    }
};

const callbackManager$2 = new CallbackManager();
let compassListener;
/**
 * Note: 按系统类型获取对应绝对 orientation 事件名，因为安卓系统中直接监听 deviceorientation 事件得到的不是绝对 orientation
 */
const deviceorientationEventName = ['absolutedeviceorientation', 'deviceorientationabsolute', 'deviceorientation'].find(item => {
    if ('on' + item in window) {
        return item;
    }
}) || '';
/**
 * 停止监听罗盘数据
 */
const stopCompass = ({ success, fail, complete } = {}) => {
    const handle = new MethodHandler({ name: 'stopCompass', success, fail, complete });
    try {
        window.removeEventListener(deviceorientationEventName, compassListener, true);
        return handle.success();
    }
    catch (e) {
        return handle.fail({ errMsg: e.message });
    }
};
let CompassChangeTrigger = false;
/**
 * 开始监听罗盘数据
 */
const startCompass = ({ success, fail, complete } = {}) => {
    const handle = new MethodHandler({ name: 'startCompass', success, fail, complete });
    try {
        if (deviceorientationEventName !== '') {
            if (compassListener) {
                stopCompass();
            }
            compassListener = throttle((evt) => {
                const isAndroid = getDeviceInfo().system === 'AndroidOS';
                if (isAndroid && !evt.absolute && !CompassChangeTrigger) {
                    CompassChangeTrigger = true;
                    console.warn('Warning: In \'onCompassChange\', your browser is not supported to get the orientation relative to the earth, the orientation data will be related to the initial orientation of the device .');
                }
                const alpha = evt.alpha || 0;
                /**
                 * 由于平台差异，accuracy 在 iOS/Android 的值不同。
                 * - iOS：accuracy 是一个 number 类型的值，表示相对于磁北极的偏差。0 表示设备指向磁北，90 表示指向东，180 表示指向南，依此类推。
                 * - Android：accuracy 是一个 string 类型的枚举值。
                 */
                const accuracy = isAndroid ? evt.absolute ? 'high' : 'medium' : alpha;
                callbackManager$2.trigger({
                    direction: 360 - alpha,
                    accuracy: accuracy
                });
            }, 5000);
            window.addEventListener(deviceorientationEventName, compassListener, true);
        }
        else {
            throw new Error('compass is not supported');
        }
        return handle.success();
    }
    catch (e) {
        return handle.fail({ errMsg: e.message });
    }
};
/**
 * 监听罗盘数据变化事件。频率：5 次/秒，接口调用后会自动开始监听，可使用 wx.stopCompass 停止监听。
 */
const onCompassChange = callback => {
    callbackManager$2.add(callback);
};
/**
 * 取消监听罗盘数据变化事件，参数为空，则取消所有的事件监听。
 */
const offCompassChange = callback => {
    callbackManager$2.remove(callback);
};

// 联系人
const chooseContact = temporarilyNotSupport('chooseContact');
const addPhoneContact = temporarilyNotSupport('addPhoneContact');

// 加密
const getRandomValues = temporarilyNotSupport('getRandomValues');

// 陀螺仪
const stopGyroscope = temporarilyNotSupport('stopGyroscope');
const startGyroscope = temporarilyNotSupport('startGyroscope');
const onGyroscopeChange = temporarilyNotSupport('onGyroscopeChange');
const offGyroscopeChange = temporarilyNotSupport('offGyroscopeChange');

// 蓝牙-信标(Beacon)
const stopBeaconDiscovery = temporarilyNotSupport('stopBeaconDiscovery');
const startBeaconDiscovery = temporarilyNotSupport('startBeaconDiscovery');
const onBeaconUpdate = temporarilyNotSupport('onBeaconUpdate');
const onBeaconServiceChange = temporarilyNotSupport('onBeaconServiceChange');
const offBeaconUpdate = temporarilyNotSupport('offBeaconUpdate');
const offBeaconServiceChange = temporarilyNotSupport('offBeaconServiceChange');
const getBeacons = temporarilyNotSupport('getBeacons');

// 键盘
const onKeyboardHeightChange = temporarilyNotSupport('onKeyboardHeightChange');
const offKeyboardHeightChange = temporarilyNotSupport('offKeyboardHeightChange');
const hideKeyboard = temporarilyNotSupport('hideKeyboard');
const getSelectedTextRange = temporarilyNotSupport('getSelectedTextRange');

// 内存
const onMemoryWarning = temporarilyNotSupport('onMemoryWarning');
const offMemoryWarning = temporarilyNotSupport('offMemoryWarning');

const callbackManager$1 = new CallbackManager();
let deviceMotionListener;
const INTERVAL_MAP = {
    game: {
        interval: 20,
        frequency: 50
    },
    ui: {
        interval: 60,
        frequency: 16.67
    },
    normal: {
        interval: 200,
        frequency: 5
    }
};
/**
 * 停止监听设备方向的变化。
 */
const stopDeviceMotionListening = ({ success, fail, complete } = {}) => {
    const handle = new MethodHandler({ name: 'stopDeviceMotionListening', success, fail, complete });
    try {
        window.removeEventListener('deviceorientation', deviceMotionListener, true);
        return handle.success();
    }
    catch (e) {
        return handle.fail({ errMsg: e.message });
    }
};
/**
 * 开始监听设备方向的变化。
 */
const startDeviceMotionListening = ({ interval = 'normal', success, fail, complete } = {}) => {
    const handle = new MethodHandler({ name: 'startDeviceMotionListening', success, fail, complete });
    try {
        const intervalObj = INTERVAL_MAP[interval];
        if (window.DeviceOrientationEvent) {
            if (deviceMotionListener) {
                stopDeviceMotionListening();
            }
            deviceMotionListener = throttle((evt) => {
                callbackManager$1.trigger({
                    alpha: evt.alpha,
                    beta: evt.beta,
                    gamma: evt.gamma
                });
            }, intervalObj.interval);
            window.addEventListener('deviceorientation', deviceMotionListener, true);
        }
        else {
            throw new Error('deviceMotion is not supported');
        }
        return handle.success();
    }
    catch (e) {
        return handle.fail({ errMsg: e.message });
    }
};
/**
 * 监听设备方向变化事件。
 */
const onDeviceMotionChange = callback => {
    callbackManager$1.add(callback);
};
/**
 * 取消监听设备方向变化事件，参数为空，则取消所有的事件监听。
 */
const offDeviceMotionChange = callback => {
    callbackManager$1.remove(callback);
};

function getConnection() {
    // @ts-ignore
    return navigator.connection || navigator.mozConnection || navigator.webkitConnection || navigator.msConnection;
}
const getNetworkType = (options = {}) => {
    const connection = getConnection();
    const { success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'getNetworkType', success, fail, complete });
    let networkType = 'unknown';
    // 浏览器不支持获取网络状态
    if (!connection) {
        return handle.success({ networkType });
    }
    // Supports only the navigator.connection.type value which doesn't match the latest spec.
    // https://www.davidbcalhoun.com/2010/using-navigator-connection-android/
    if (!isNaN(Number(connection.type))) {
        switch (connection.type) {
            // @ts-ignore
            case connection.WIFI:
                networkType = 'wifi';
                break;
            // @ts-ignore
            case connection.CELL_3G:
                networkType = '3g';
                break;
            // @ts-ignore
            case connection.CELL_2G:
                networkType = '2g';
                break;
            default:
                // ETHERNET, UNKNOWN
                networkType = 'unknown';
        }
    }
    else if (connection.type) {
        // @ts-ignore
        networkType = connection.type; // Only supports the type value.
        // @ts-ignore
    }
    else if (connection.effectiveType) {
        // @ts-ignore
        networkType = connection.effectiveType;
    }
    return handle.success({ networkType });
};
const networkStatusManager = new CallbackManager();
const networkStatusListener = async () => {
    const { networkType } = await getNetworkType();
    const isConnected = networkType !== 'none';
    const obj = { isConnected, networkType };
    networkStatusManager.trigger(obj);
};
/**
 * 在最近的八次网络请求中, 出现下列三个现象之一则判定弱网。
 * - 出现三次以上连接超时
 * - 出现三次 rtt 超过 400
 * - 出现三次以上的丢包
 * > 弱网事件通知规则是: 弱网状态变化时立即通知, 状态不变时 30s 内最多通知一次。
 */
const onNetworkWeakChange = temporarilyNotSupport('onNetworkWeakChange');
const onNetworkStatusChange = callback => {
    networkStatusManager.add(callback);
    const connection = getConnection();
    if (connection && networkStatusManager.count() === 1) {
        connection.addEventListener('change', networkStatusListener);
    }
};
const offNetworkWeakChange = temporarilyNotSupport('offNetworkStatusChange');
const offNetworkStatusChange = callback => {
    networkStatusManager.remove(callback);
    const connection = getConnection();
    if (connection && networkStatusManager.count() === 0) {
        connection.removeEventListener('change', networkStatusListener);
    }
};
const getLocalIPAddress = temporarilyNotSupport('getLocalIPAddress');

// NFC
const stopHCE = temporarilyNotSupport('stopHCE');
const startHCE = temporarilyNotSupport('startHCE');
const sendHCEMessage = temporarilyNotSupport('sendHCEMessage');
const onHCEMessage = temporarilyNotSupport('onHCEMessage');
const offHCEMessage = temporarilyNotSupport('offHCEMessage');
const getNFCAdapter = temporarilyNotSupport('getNFCAdapter');
const getHCEState = temporarilyNotSupport('getHCEState');

const makePhoneCall = (options) => {
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `makePhoneCall:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { phoneNumber, success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'makePhoneCall', success, fail, complete });
    if (typeof phoneNumber !== 'string') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'phoneNumber',
                correct: 'String',
                wrong: phoneNumber
            })
        });
    }
    window.location.href = `tel:${phoneNumber}`;
    return handle.success();
};

// 扫码
const scanCode = processOpenApi({
    name: 'scanQRCode',
    defaultOptions: { needResult: 1 },
    formatResult: res => ({
        errMsg: res.errMsg === 'scanQRCode:ok' ? 'scanCode:ok' : res.errMsg,
        result: res.resultStr
    })
});

// 屏幕
const setVisualEffectOnCapture = temporarilyNotSupport('setVisualEffectOnCapture');
const setScreenBrightness = temporarilyNotSupport('setScreenBrightness');
const setKeepScreenOn = temporarilyNotSupport('setKeepScreenOn');
const onUserCaptureScreen = temporarilyNotSupport('onUserCaptureScreen');
const offUserCaptureScreen = temporarilyNotSupport('offUserCaptureScreen');
const getScreenBrightness = temporarilyNotSupport('getScreenBrightness');

const vibrator = function vibrator(mm) {
    try {
        return window.navigator.vibrate(mm);
    }
    catch (e) {
        console.warn('当前浏览器不支持vibrate');
    }
};
/**
 * 使手机发生较短时间的振动（15 ms）。仅在 iPhone 7 / 7 Plus 以上及 Android 机型生效
 */
const vibrateShort = ({ success, fail, complete } = {}) => {
    const handle = new MethodHandler({ name: 'vibrateShort', success, fail, complete });
    if (vibrator) {
        vibrator(15);
        return handle.success();
    }
    else {
        return handle.fail();
    }
};
/**
 * 使手机发生较长时间的振动（400 ms)
 */
const vibrateLong = ({ success, fail, complete } = {}) => {
    const handle = new MethodHandler({ name: 'vibrateLong', success, fail, complete });
    if (vibrator) {
        vibrator(400);
        return handle.success();
    }
    else {
        return handle.fail();
    }
};

// Wi-Fi
const stopWifi = temporarilyNotSupport('stopWifi');
const startWifi = temporarilyNotSupport('startWifi');
const setWifiList = temporarilyNotSupport('setWifiList');
const onWifiConnectedWithPartialInfo = temporarilyNotSupport('onWifiConnectedWithPartialInfo');
const onWifiConnected = temporarilyNotSupport('onWifiConnected');
const onGetWifiList = temporarilyNotSupport('onGetWifiList');
const offWifiConnected = temporarilyNotSupport('offWifiConnected');
const offGetWifiList = temporarilyNotSupport('offGetWifiList');
const getWifiList = temporarilyNotSupport('getWifiList');
const getConnectedWifi = temporarilyNotSupport('getConnectedWifi');
const connectWifi = temporarilyNotSupport('connectWifi');

// 第三方平台
const getExtConfigSync = temporarilyNotSupport('getExtConfigSync');
const getExtConfig = temporarilyNotSupport('getExtConfig');

// 文件
const saveFileToDisk = temporarilyNotSupport('saveFileToDisk');
const saveFile = temporarilyNotSupport('saveFile');
const removeSavedFile = temporarilyNotSupport('removeSavedFile');
const openDocument = temporarilyNotSupport('openDocument');
const getSavedFileList = temporarilyNotSupport('getSavedFileList');
const getSavedFileInfo = temporarilyNotSupport('getSavedFileInfo');
const getFileSystemManager = temporarilyNotSupport('getFileSystemManager');
const getFileInfo = temporarilyNotSupport('getFileInfo');

const getApp = function () {
    return Taro__default["default"].getCurrentInstance().app;
};
// 自定义组件
const getCurrentInstance = Taro__default["default"].getCurrentInstance;

const getLocationByW3CApi = (options) => {
    var _a;
    // 断言 options 必须是 Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `getLocation:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    // 解构回调函数
    const { success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'getLocation', success, fail, complete });
    // const defaultMaximumAge = 5 * 1000
    const positionOptions = {
        enableHighAccuracy: options.isHighAccuracy || (options.altitude != null),
        // maximumAge: defaultMaximumAge, // 允许取多久以内的缓存位置
        timeout: options.highAccuracyExpireTime // 高精度定位超时时间
    };
    // Web端API实现暂时仅支持GPS坐标系
    if (((_a = options.type) === null || _a === void 0 ? void 0 : _a.toUpperCase()) !== 'WGS84') {
        return handle.fail({
            errMsg: 'This coordinate system type is not temporarily supported'
        });
    }
    // 判断当前浏览器是否支持位置API
    const geolocationSupported = navigator.geolocation;
    if (!geolocationSupported) {
        return handle.fail({
            errMsg: 'The current browser does not support this feature'
        });
    }
    // 开始获取位置
    return new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition((position) => {
            const result = {
                /** 位置的精确度 */
                accuracy: position.coords.accuracy,
                /** 高度，单位 m */
                altitude: position.coords.altitude,
                /** 水平精度，单位 m */
                horizontalAccuracy: position.coords.accuracy,
                /** 纬度，范围为 -90~90，负数表示南纬 */
                latitude: position.coords.latitude,
                /** 经度，范围为 -180~180，负数表示西经 */
                longitude: position.coords.longitude,
                /** 速度，单位 m/s */
                speed: position.coords.speed,
                /** 垂直精度，单位 m（Android 无法获取，返回 0） */
                verticalAccuracy: position.coords.altitudeAccuracy || 0,
                /** 调用结果,自动补充 */
                errMsg: ''
            };
            handle.success(result, resolve);
        }, (error) => {
            handle.fail({ errMsg: error.message }, reject);
        }, positionOptions);
    });
};
const getLocation = processOpenApi({
    name: 'getLocation',
    standardMethod: getLocationByW3CApi
});

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".taro_choose_location {\r\n  position: fixed;\r\n  display: flex;\r\n  flex-direction: column;\r\n  width: 100%;\r\n  height: 100%;\r\n  top: 100%;\r\n  background-color: #fff;\r\n  transition: ease top .3s;\r\n  z-index: 1;\r\n}\r\n\r\n.taro_choose_location_bar {\r\n  display: flex;\r\n  flex: 0 95px;\r\n  height: 95px;\r\n  background-color: #ededed;\r\n  color: #090909;\r\n}\r\n\r\n.taro_choose_location_back {\r\n  flex: 0 45px;\r\n  position: relative;\r\n  width: 33px;\r\n  height: 30px;\r\n  margin-top: 30px;\r\n}\r\n\r\n.taro_choose_location_back::before {\r\n  content: '';\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  display: block;\r\n  width: 0;\r\n  height: 0;\r\n  border: solid 15px;\r\n  border-top-color: transparent;\r\n  border-right-color: #090909;\r\n  border-bottom-color: transparent;\r\n  border-left-color: transparent;\r\n}\r\n\r\n.taro_choose_location_back::after {\r\n  content: '';\r\n  position: absolute;\r\n  display: block;\r\n  width: 0;\r\n  height: 0;\r\n  top: 0;\r\n  left: 3px;\r\n  border: solid 15px;\r\n  border-top-color: transparent;\r\n  border-right-color: #ededed;\r\n  border-bottom-color: transparent;\r\n  border-left-color: transparent;\r\n}\r\n\r\n.taro_choose_location_title {\r\n  flex: 1;\r\n  line-height: 95px;\r\n  padding-left: 30px;\r\n}\r\n\r\n.taro_choose_location_submit {\r\n  width: 110px;\r\n  height: 60px;\r\n  color: #fff;\r\n  background-color: #08bf62;\r\n  border: none;\r\n  font-size: 28px;\r\n  line-height: 60px;\r\n  padding: 0;\r\n  margin: 18px 30px 0 0;\r\n}\r\n\r\n.taro_choose_location_frame {\r\n  flex: 1;\r\n}";
var stylesheet=".taro_choose_location {\r\n  position: fixed;\r\n  display: flex;\r\n  flex-direction: column;\r\n  width: 100%;\r\n  height: 100%;\r\n  top: 100%;\r\n  background-color: #fff;\r\n  transition: ease top .3s;\r\n  z-index: 1;\r\n}\r\n\r\n.taro_choose_location_bar {\r\n  display: flex;\r\n  flex: 0 95px;\r\n  height: 95px;\r\n  background-color: #ededed;\r\n  color: #090909;\r\n}\r\n\r\n.taro_choose_location_back {\r\n  flex: 0 45px;\r\n  position: relative;\r\n  width: 33px;\r\n  height: 30px;\r\n  margin-top: 30px;\r\n}\r\n\r\n.taro_choose_location_back::before {\r\n  content: '';\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  display: block;\r\n  width: 0;\r\n  height: 0;\r\n  border: solid 15px;\r\n  border-top-color: transparent;\r\n  border-right-color: #090909;\r\n  border-bottom-color: transparent;\r\n  border-left-color: transparent;\r\n}\r\n\r\n.taro_choose_location_back::after {\r\n  content: '';\r\n  position: absolute;\r\n  display: block;\r\n  width: 0;\r\n  height: 0;\r\n  top: 0;\r\n  left: 3px;\r\n  border: solid 15px;\r\n  border-top-color: transparent;\r\n  border-right-color: #ededed;\r\n  border-bottom-color: transparent;\r\n  border-left-color: transparent;\r\n}\r\n\r\n.taro_choose_location_title {\r\n  flex: 1;\r\n  line-height: 95px;\r\n  padding-left: 30px;\r\n}\r\n\r\n.taro_choose_location_submit {\r\n  width: 110px;\r\n  height: 60px;\r\n  color: #fff;\r\n  background-color: #08bf62;\r\n  border: none;\r\n  font-size: 28px;\r\n  line-height: 60px;\r\n  padding: 0;\r\n  margin: 18px 30px 0 0;\r\n}\r\n\r\n.taro_choose_location_frame {\r\n  flex: 1;\r\n}";
styleInject(css_248z,{"insertAt":"top"});

function createLocationChooser(handler, key = LOCATION_APIKEY, mapOpt = {}) {
    var _a, _b, _c;
    const { latitude, longitude, ...opts } = mapOpt;
    const query = {
        key,
        type: 1,
        coord: ((_a = mapOpt.coord) !== null && _a !== void 0 ? _a : [latitude, longitude].every(e => Number(e) >= 0)) ? `${latitude},${longitude}` : undefined,
        referer: 'myapp',
        ...opts
    };
    const html = `
<div class='taro_choose_location'>
  <div class='taro_choose_location_bar'>
    <div class='taro_choose_location_back'></div>
    <p class='taro_choose_location_title'>位置</p>
    <button class='taro_choose_location_submit'>完成</button>
  </div>
  <iframe class='taro_choose_location_frame' frameborder='0' src="https://apis.map.qq.com/tools/locpicker?${queryString.stringify(query, { arrayFormat: 'comma', skipNull: true })}" />
</div>
`;
    const container = document.createElement('div');
    container.innerHTML = html;
    const main = container.querySelector('.taro_choose_location');
    function show() {
        setTimeout(() => {
            main.style.top = '0';
        });
    }
    function hide() {
        main.style.top = '100%';
    }
    function back() {
        hide();
        handler({ errMsg: 'cancel' });
    }
    function submit() {
        hide();
        handler();
    }
    function remove() {
        container.remove();
        window.removeEventListener('popstate', back);
    }
    (_b = container.querySelector('.taro_choose_location_back')) === null || _b === void 0 ? void 0 : _b.addEventListener('click', back);
    (_c = container.querySelector('.taro_choose_location_submit')) === null || _c === void 0 ? void 0 : _c.addEventListener('click', submit);
    window.addEventListener('popstate', back);
    return {
        show,
        remove,
        container
    };
}
/**
 * 打开地图选择位置。
 */
const chooseLocation = ({ success, fail, complete, mapOpts } = {}) => {
    const key = LOCATION_APIKEY;
    const handle = new MethodHandler({ name: 'chooseLocation', success, fail, complete });
    return new Promise((resolve, reject) => {
        const chooseLocation = {};
        if (!key) {
            console.warn('chooseLocation api 依赖腾讯地图定位api，需要在 defineConstants 中配置 LOCATION_APIKEY');
            return handle.fail({
                errMsg: 'LOCATION_APIKEY needed'
            }, reject);
        }
        const onMessage = event => {
            // 接收位置信息，用户选择确认位置点后选点组件会触发该事件，回传用户的位置信息
            const loc = event.data;
            // 防止其他应用也会向该页面 post 信息，需判断 module 是否为'locationPicker'
            if (!loc || loc.module !== 'locationPicker')
                return;
            chooseLocation.name = loc.poiname;
            chooseLocation.address = loc.poiaddress;
            chooseLocation.latitude = loc.latlng.lat;
            chooseLocation.longitude = loc.latlng.lng;
        };
        const chooser = createLocationChooser(res => {
            window.removeEventListener('message', onMessage, false);
            setTimeout(() => {
                chooser.remove();
            }, 300);
            if (res) {
                return handle.fail(res, reject);
            }
            else {
                if (chooseLocation.latitude && chooseLocation.longitude) {
                    return handle.success(chooseLocation, resolve);
                }
                else {
                    return handle.fail({}, reject);
                }
            }
        }, key, mapOpts);
        document.body.appendChild(chooser.container);
        window.addEventListener('message', onMessage, false);
        chooser.show();
    });
};

// 位置
const stopLocationUpdate = temporarilyNotSupport('stopLocationUpdate');
const startLocationUpdateBackground = temporarilyNotSupport('startLocationUpdateBackground');
const startLocationUpdate = temporarilyNotSupport('startLocationUpdate');
const openLocation = processOpenApi({
    name: 'openLocation',
    defaultOptions: { scale: 18 }
});
const onLocationChangeError = temporarilyNotSupport('onLocationChangeError');
const onLocationChange = temporarilyNotSupport('onLocationChange');
const offLocationChangeError = temporarilyNotSupport('offLocationChangeError');
const offLocationChange = temporarilyNotSupport('offLocationChange');
const choosePoi = temporarilyNotSupport('choosePoi');

class InnerAudioContext {
    constructor() {
        this.__startTime = 0;
        this.play = () => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.play(); };
        this.pause = () => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.pause(); };
        this.stop = () => {
            this.pause();
            this.seek(0);
            this.stopStack.trigger();
        };
        this.seek = (position) => {
            if (this.Instance) {
                this.Instance.currentTime = position;
            }
        };
        /**
         * @TODO destroy得并不干净
         */
        this.destroy = () => {
            this.stop();
            if (this.Instance) {
                document.body.removeChild(this.Instance);
                this.Instance = undefined;
            }
        };
        this.onCanplay = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener('canplay', callback); };
        this.onPlay = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener('play', callback); };
        this.onPause = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener('pause', callback); };
        this.onStop = (callback = () => { }) => this.stopStack.add(callback);
        this.onEnded = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener('ended', callback); };
        this.onTimeUpdate = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener('timeupdate', callback); };
        this.onError = (callback) => this.errorStack.add(callback);
        this.onWaiting = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener('waiting', callback); };
        this.onSeeking = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener('seeking', callback); };
        this.onSeeked = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener('seeked', callback); };
        this.offCanplay = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener('canplay', callback); };
        this.offPlay = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener('play', callback); };
        this.offPause = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener('pause', callback); };
        this.offStop = (callback = () => { }) => this.stopStack.remove(callback);
        this.offEnded = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener('ended', callback); };
        this.offTimeUpdate = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener('timeupdate', callback); };
        this.offError = (callback = () => { }) => this.errorStack.remove(callback);
        this.offWaiting = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener('waiting', callback); };
        this.offSeeking = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener('seeking', callback); };
        this.offSeeked = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener('seeked', callback); };
        this.Instance = new Audio();
        this.errorStack = new CallbackManager();
        this.stopStack = new CallbackManager();
        Taro__default["default"].eventCenter.on('__taroRouterChange', () => { this.stop(); });
        this.onPlay(() => {
            if (this.currentTime !== this.startTime) {
                this.seek(this.startTime);
            }
        });
    }
    set autoplay(e) { this.setProperty('autoplay', e); }
    get autoplay() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.autoplay) || false; }
    get buffered() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.buffered.length) || 0; }
    get currentTime() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.currentTime) || 0; }
    get duration() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.duration) || 0; }
    set loop(e) { this.setProperty('loop', e); }
    get loop() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.loop) || false; }
    get paused() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.paused) || true; }
    set src(e) { this.setProperty('src', e); }
    get src() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.src) || ''; }
    set volume(e) { this.setProperty('volume', e); }
    get volume() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.volume) || 0; }
    set playbackRate(e) { this.setProperty('playbackRate', e); }
    get playbackRate() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.playbackRate) || 0; }
    set obeyMuteSwitch(_e) { permanentlyNotSupport('InnerAudioContext.obeyMuteSwitch')(); }
    get obeyMuteSwitch() { return true; }
    set startTime(e) { this.__startTime = e; }
    get startTime() { return this.__startTime || 0; }
    set referrerPolicy(e) { var _a; (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.setAttribute('referrerpolicy', e); }
    get referrerPolicy() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.getAttribute('referrerpolicy')) || 'origin'; }
    setProperty(key, value) {
        if (this.Instance) {
            this.Instance[key] = value;
        }
    }
}

// 音频
const stopVoice = temporarilyNotSupport('stopVoice');
const setInnerAudioOption = temporarilyNotSupport('setInnerAudioOption');
const playVoice = temporarilyNotSupport('playVoice');
const pauseVoice = temporarilyNotSupport('pauseVoice');
const getAvailableAudioSources = temporarilyNotSupport('getAvailableAudioSources');
const createWebAudioContext = temporarilyNotSupport('createWebAudioContext');
const createMediaAudioPlayer = temporarilyNotSupport('createMediaAudioPlayer');
/**
 * 创建内部 audio 上下文 InnerAudioContext 对象。
 */
const createInnerAudioContext = () => new InnerAudioContext();
const createAudioContext = temporarilyNotSupport('createAudioContext');

class BackgroundAudioManager {
    constructor() {
        this.__startTime = 0;
        this.play = () => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.play(); };
        this.pause = () => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.pause(); };
        this.seek = (position) => {
            if (this.Instance) {
                this.Instance.currentTime = position;
            }
        };
        this.stop = () => {
            this.pause();
            this.seek(0);
            this.stopStack.trigger();
        };
        this.onCanplay = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener('canplay', callback); };
        this.onWaiting = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener('waiting', callback); };
        this.onError = (callback) => this.errorStack.add(callback);
        this.onPlay = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener('play', callback); };
        this.onPause = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener('pause', callback); };
        this.onSeeking = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener('seeking', callback); };
        this.onSeeked = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener('seeked', callback); };
        this.onEnded = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener('ended', callback); };
        this.onStop = (callback = () => { }) => this.stopStack.add(callback);
        this.onTimeUpdate = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener('timeupdate', callback); };
        this.onPrev = permanentlyNotSupport('BackgroundAudioManager.onPrev');
        this.onNext = permanentlyNotSupport('BackgroundAudioManager.onNext');
        this.offCanplay = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener('canplay', callback); };
        this.offWaiting = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener('waiting', callback); };
        this.offError = (callback = () => { }) => this.errorStack.remove(callback);
        this.offPlay = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener('play', callback); };
        this.offPause = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener('pause', callback); };
        this.offSeeking = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener('seeking', callback); };
        this.offSeeked = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener('seeked', callback); };
        this.offEnded = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener('ended', callback); };
        this.offStop = (callback = () => { }) => this.stopStack.remove(callback);
        this.offTimeUpdate = (callback = () => { }) => { var _a; return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener('timeupdate', callback); };
        this.offPrev = permanentlyNotSupport('BackgroundAudioManager.offPrev');
        this.offNext = permanentlyNotSupport('BackgroundAudioManager.offNext');
        this.Instance = new Audio();
        this.errorStack = new CallbackManager();
        this.stopStack = new CallbackManager();
        this.Instance.autoplay = true;
        this.onPlay(() => {
            if (this.currentTime !== this.startTime) {
                this.seek(this.startTime);
            }
        });
    }
    set src(e) { this.setProperty('src', e); }
    get src() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.src) || ''; }
    set startTime(e) { this.__startTime = e; }
    get startTime() { return this.__startTime || 0; }
    set title(e) { this.dataset('title', e); }
    get title() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.title) || ''; }
    set epname(e) { this.dataset('epname', e); }
    get epname() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.epname) || ''; }
    set singer(e) { this.dataset('singer', e); }
    get singer() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.singer) || ''; }
    set coverImgUrl(e) { this.dataset('coverImgUrl', e); }
    get coverImgUrl() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.coverImgUrl) || ''; }
    set webUrl(e) { this.dataset('webUrl', e); }
    get webUrl() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.webUrl) || ''; }
    set protocol(e) { this.dataset('protocol', e); }
    get protocol() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.protocol) || ''; }
    set playbackRate(e) { this.setProperty('playbackRate', e); }
    get playbackRate() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.playbackRate) || 0; }
    get duration() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.duration) || 0; }
    get currentTime() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.currentTime) || 0; }
    get paused() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.paused) || false; }
    get buffered() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.buffered.length) || 0; }
    set referrerPolicy(e) { var _a; (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.setAttribute('referrerpolicy', e); }
    get referrerPolicy() { var _a; return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.getAttribute('referrerpolicy')) || 'origin'; }
    setProperty(key, value) {
        if (this.Instance) {
            this.Instance[key] = value;
        }
    }
    dataset(key, value) {
        if (this.Instance) {
            this.Instance.dataset[key] = value;
        }
    }
}

// 背景音频
const stopBackgroundAudio = temporarilyNotSupport('stopBackgroundAudio');
const seekBackgroundAudio = temporarilyNotSupport('seekBackgroundAudio');
const playBackgroundAudio = temporarilyNotSupport('playBackgroundAudio');
const pauseBackgroundAudio = temporarilyNotSupport('pauseBackgroundAudio');
const onBackgroundAudioStop = temporarilyNotSupport('onBackgroundAudioStop');
const onBackgroundAudioPlay = temporarilyNotSupport('onBackgroundAudioPlay');
const onBackgroundAudioPause = temporarilyNotSupport('onBackgroundAudioPause');
const getBackgroundAudioPlayerState = temporarilyNotSupport('getBackgroundAudioPlayerState');
/**
 * 获取全局唯一的背景音频管理器
 */
const getBackgroundAudioManager = () => new BackgroundAudioManager();

// 相机
const createCameraContext = temporarilyNotSupport('createCameraContext');

/**
 * previewImage api基于开源的React组件[react-wx-images-viewer](https://github.com/react-ld/react-wx-images-viewer)开发，感谢！
 */
/**
 * 在新页面中全屏预览图片。预览的过程中用户可以进行保存图片、发送给朋友等操作。
 */
const previewImage = async (options) => {
    function loadImage(url, loadFail) {
        return new Promise((resolve) => {
            const item = document.createElement('taro-swiper-item-core');
            item.style.cssText = 'display:flex;align-items:start;justify-content:center;overflow-y:scroll;';
            const image = new Image();
            image.style.maxWidth = '100%';
            image.src = url;
            const div = document.createElement('div');
            div.style.cssText = 'display:flex;align-items:center;justify-content:center;max-width:100%;min-height:100%;';
            div.appendChild(image);
            item.appendChild(div);
            // Note: 等待图片加载完后返回，会导致轮播被卡住
            resolve(item);
            if (typeof loadFail === 'function') {
                image.addEventListener('error', (err) => {
                    loadFail({ errMsg: err.message });
                });
            }
        });
    }
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `previewImage:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { urls = [], current = '', success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'previewImage', success, fail, complete });
    const container = document.createElement('div');
    container.classList.add('preview-image');
    container.style.cssText = 'position:fixed;top:0;left:0;z-index:1050;width:100%;height:100%;overflow:hidden;outline:0;background-color:#111;';
    container.addEventListener('click', () => {
        container.remove();
    });
    const swiper = document.createElement('taro-swiper-core');
    // @ts-ignore
    swiper.full = true;
    let children = [];
    try {
        children = await Promise.all(urls.map(e => loadImage(e, fail)));
    }
    catch (error) {
        return handle.fail({
            errMsg: error
        });
    }
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        swiper.appendChild(child);
    }
    const currentIndex = urls.indexOf(current);
    // @ts-ignore
    swiper.current = currentIndex;
    container.appendChild(swiper);
    document.body.appendChild(container);
    return handle.success();
};

/**
 * 获取图片信息。网络图片需先配置download域名才能生效。
 */
const getImageInfo = (options) => {
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `getImageInfo:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const getBase64Image = (image) => {
        try {
            const canvas = document.createElement('canvas');
            canvas.width = image.width;
            canvas.height = image.height;
            const ctx = canvas.getContext('2d');
            ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, image.width, image.height);
            return canvas.toDataURL('image/png');
        }
        catch (e) {
            console.error('getImageInfo:get base64 fail', e);
        }
    };
    const { src, success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'getImageInfo', success, fail, complete });
    return new Promise((resolve, reject) => {
        const image = new Image();
        image.crossOrigin = '';
        image.onload = () => {
            handle.success({
                width: image.naturalWidth,
                height: image.naturalHeight,
                path: getBase64Image(image) || src
            }, resolve);
        };
        image.onerror = (e) => {
            handle.fail({
                errMsg: e.message
            }, reject);
        };
        image.src = src;
    });
};

/**
 * 从本地相册选择图片或使用相机拍照。
 */
const chooseImage = function (options) {
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `chooseImage:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { count = 1, success, fail, complete, imageId = 'taroChooseImage', sourceType = ['album', 'camera'] } = options;
    const handle = new MethodHandler({ name: 'chooseImage', success, fail, complete });
    const res = {
        tempFilePaths: [],
        tempFiles: []
    };
    const sourceTypeString = sourceType && sourceType.toString();
    const acceptableSourceType = ['user', 'environment', 'camera'];
    if (count && typeof count !== 'number') {
        res.errMsg = getParameterError({
            para: 'count',
            correct: 'Number',
            wrong: count
        });
        return handle.fail(res);
    }
    let el = document.getElementById(imageId);
    if (!el) {
        const obj = document.createElement('input');
        obj.setAttribute('type', 'file');
        obj.setAttribute('id', imageId);
        if (count > 1) {
            obj.setAttribute('multiple', 'multiple');
        }
        if (acceptableSourceType.indexOf(sourceTypeString) > -1) {
            obj.setAttribute('capture', sourceTypeString);
        }
        obj.setAttribute('accept', 'image/*');
        obj.setAttribute('style', 'position: fixed; top: -4000px; left: -3000px; z-index: -300;');
        document.body.appendChild(obj);
        el = document.getElementById(imageId);
    }
    else {
        if (count > 1) {
            el.setAttribute('multiple', 'multiple');
        }
        else {
            el.removeAttribute('multiple');
        }
        if (acceptableSourceType.indexOf(sourceTypeString) > -1) {
            el.setAttribute('capture', sourceTypeString);
        }
        else {
            el.removeAttribute('capture');
        }
    }
    return new Promise(resolve => {
        const TaroMouseEvents = document.createEvent('MouseEvents');
        TaroMouseEvents.initEvent('click', true, true);
        if (el) {
            el.dispatchEvent(TaroMouseEvents);
            el.onchange = function (e) {
                const target = e.target;
                if (target) {
                    const files = target.files || [];
                    const arr = [...files];
                    arr && arr.forEach(item => {
                        var _a, _b;
                        const blob = new Blob([item], {
                            type: item.type
                        });
                        const url = URL.createObjectURL(blob);
                        (_a = res.tempFilePaths) === null || _a === void 0 ? void 0 : _a.push(url);
                        (_b = res.tempFiles) === null || _b === void 0 ? void 0 : _b.push({ path: url, size: item.size, type: item.type, originalFileObj: item });
                    });
                    handle.success(res, resolve);
                    target.value = '';
                }
            };
        }
    });
};

// 图片
const saveImageToPhotosAlbum = temporarilyNotSupport('saveImageToPhotosAlbum');
const previewMedia = temporarilyNotSupport('previewMedia');
const compressImage = temporarilyNotSupport('compressImage');
const chooseMessageFile = temporarilyNotSupport('chooseMessageFile');

// 实时音视频
const createLivePusherContext = temporarilyNotSupport('createLivePusherContext');
const createLivePlayerContext = temporarilyNotSupport('createLivePlayerContext');

// 地图
const createMapContext = temporarilyNotSupport('createMapContext');

// 画面录制器
const createMediaRecorder = temporarilyNotSupport('createMediaRecorder');

// 录音
const stopRecord = temporarilyNotSupport('stopRecord');
const startRecord = temporarilyNotSupport('startRecord');
const getRecorderManager = temporarilyNotSupport('getRecorderManager');

// 视频
const saveVideoToPhotosAlbum = temporarilyNotSupport('saveVideoToPhotosAlbum');
const openVideoEditor = temporarilyNotSupport('openVideoEditor');
const getVideoInfo = temporarilyNotSupport('getVideoInfo');
/**
 * 创建 video 上下文 VideoContext 对象。
 */
const createVideoContext = (id, inst) => {
    const el = findDOM(inst);
    // TODO HTMLVideoElement to VideoContext
    return el === null || el === void 0 ? void 0 : el.querySelector(`taro-video-core[id=${id}]`);
};
const compressVideo = temporarilyNotSupport('compressVideo');
/**
 * 拍摄视频或从手机相册中选视频。
 */
const chooseVideo = (options) => {
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `chooseVideo:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'chooseVideo', success, fail, complete });
    const res = {
        tempFilePath: '',
        duration: 0,
        size: 0,
        height: 0,
        width: 0
    };
    const inputEl = document.createElement('input');
    inputEl.setAttribute('type', 'file');
    inputEl.setAttribute('multiple', 'multiple');
    inputEl.setAttribute('accept', 'video/*');
    inputEl.setAttribute('style', 'position: fixed; top: -4000px; left: -3000px; z-index: -300;');
    document.body.appendChild(inputEl);
    return new Promise(resolve => {
        const TaroMouseEvents = document.createEvent('MouseEvents');
        TaroMouseEvents.initEvent('click', true, true);
        inputEl.dispatchEvent(TaroMouseEvents);
        inputEl.onchange = function (e) {
            var _a;
            const target = e.target;
            const file = (_a = target.files) === null || _a === void 0 ? void 0 : _a[0];
            const reader = new FileReader();
            reader.onload = function (event) {
                var _a;
                const videoEl = document.createElement('video');
                const url = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;
                videoEl.preload = 'metadata';
                videoEl.src = url;
                videoEl.onloadedmetadata = () => {
                    res.tempFilePath = url;
                    res.duration = videoEl.duration;
                    res.size = event.total;
                    res.height = videoEl.videoHeight;
                    res.width = videoEl.videoHeight;
                    return handle.success(res, resolve);
                };
            };
            if (file) {
                reader.readAsDataURL(file);
            }
        };
    }).finally(() => {
        document.body.removeChild(inputEl);
    });
};
const chooseMedia = temporarilyNotSupport('chooseMedia');

// 视频解码器
const createVideoDecoder = temporarilyNotSupport('createVideoDecoder');

// 音视频合成
const createMediaContainer = temporarilyNotSupport('createMediaContainer');

// 实时语音
const updateVoIPChatMuteConfig = temporarilyNotSupport('updateVoIPChatMuteConfig');
const subscribeVoIPVideoMembers = temporarilyNotSupport('subscribeVoIPVideoMembers');
const setEnable1v1Chat = temporarilyNotSupport('setEnable1v1Chat');
const onVoIPVideoMembersChanged = temporarilyNotSupport('onVoIPVideoMembersChanged');
const onVoIPChatStateChanged = temporarilyNotSupport('onVoIPChatStateChanged');
const onVoIPChatSpeakersChanged = temporarilyNotSupport('onVoIPChatSpeakersChanged');
const onVoIPChatMembersChanged = temporarilyNotSupport('onVoIPChatMembersChanged');
const onVoIPChatInterrupted = temporarilyNotSupport('onVoIPChatInterrupted');
const offVoIPVideoMembersChanged = temporarilyNotSupport('offVoIPVideoMembersChanged');
const offVoIPChatStateChanged = temporarilyNotSupport('offVoIPChatStateChanged');
const offVoIPChatMembersChanged = temporarilyNotSupport('offVoIPChatMembersChanged');
const offVoIPChatInterrupted = temporarilyNotSupport('offVoIPChatInterrupted');
const joinVoIPChat = temporarilyNotSupport('joinVoIPChat');
const exitVoIPChat = temporarilyNotSupport('exitVoIPChat');

// 跳转
const openEmbeddedMiniProgram = temporarilyNotSupport('openEmbeddedMiniProgram');
const navigateToMiniProgram = temporarilyNotSupport('navigateToMiniProgram');
const navigateBackMiniProgram = temporarilyNotSupport('navigateBackMiniProgram');
const exitMiniProgram = temporarilyNotSupport('exitMiniProgram');

/**
 * HTTP Response Header 事件回调函数的参数
 * @typedef {Object} HeadersReceivedParam
 * @property {Object} header 开发者服务器返回的 HTTP Response Header
 */
/**
 * HTTP Response Header 事件的回调函数
 * @callback HeadersReceivedCallback
 * @param {HeadersReceivedParam} res 参数
 */
/**
 * 进度变化回调函数的参数
 * @typedef {Object} ProgressUpdateParam
 * @property {number} progress 进度百分比
 * @property {number} [totalBytesWritten] 已经下载的数据长度，单位 Bytes
 * @property {number} [totalBytesSent] 已经上传的数据长度，单位 Bytes
 * @property {number} [totalBytesExpectedToWrite] 预期需要下载的数据总长度，单位 Bytes
 * @property {number} [totalBytesExpectedToSend] 预期需要上传的数据总长度，单位 Bytes
 */
/**
 * 进度变化事件的回调函数
 * @callback ProgressUpdateCallback
 * @param {ProgressUpdateParam} res 参数
 */
const NETWORK_TIMEOUT = 60000;
const XHR_STATS = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4 // The operation is complete.
};
/**
 * 设置xhr的header
 * @param {XMLHttpRequest} xhr
 * @param {Object} header
 */
const setHeader = (xhr, header) => {
    let headerKey;
    for (headerKey in header) {
        xhr.setRequestHeader(headerKey, header[headerKey]);
    }
};
/**
 * 将 blob url 转化为文件
 * @param {string} url 要转换的 blob url
 * @returns {Promise<File>}
 */
const convertObjectUrlToBlob = url => {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'blob';
        xhr.onload = function () {
            if (this.status === 200) {
                resolve(this.response);
            }
            else {
                /* eslint-disable prefer-promise-reject-errors */
                reject({ status: this.status });
            }
        };
        xhr.send();
    });
};

const createDownloadTask = ({ url, header, success, error }) => {
    let timeout;
    const apiName = 'downloadFile';
    const xhr = new XMLHttpRequest();
    const callbackManager = {
        headersReceived: new CallbackManager(),
        progressUpdate: new CallbackManager()
    };
    xhr.open('GET', url, true);
    xhr.responseType = 'blob';
    setHeader(xhr, header);
    xhr.onprogress = e => {
        const { loaded, total } = e;
        callbackManager.progressUpdate.trigger({
            progress: Math.round(loaded / total * 100),
            totalBytesWritten: loaded,
            totalBytesExpectedToWrite: total
        });
    };
    xhr.onreadystatechange = () => {
        if (xhr.readyState !== XHR_STATS.HEADERS_RECEIVED)
            return;
        callbackManager.headersReceived.trigger({
            header: xhr.getAllResponseHeaders()
        });
    };
    xhr.onload = () => {
        const response = xhr.response;
        const status = xhr.status;
        success({
            errMsg: `${apiName}:ok`,
            statusCode: status,
            tempFilePath: window.URL.createObjectURL(response)
        });
    };
    xhr.onabort = () => {
        clearTimeout(timeout);
        error({
            errMsg: `${apiName}:fail abort`
        });
    };
    xhr.onerror = (e) => {
        error({
            errMsg: `${apiName}:fail ${e.message}`
        });
    };
    /**
     * 中断任务
     */
    const abort = () => {
        xhr.abort();
    };
    const send = () => {
        xhr.send();
        timeout = setTimeout(() => {
            xhr.onabort = null;
            xhr.onload = null;
            xhr.onprogress = null;
            xhr.onreadystatechange = null;
            xhr.onerror = null;
            abort();
            error({
                errMsg: `${apiName}:fail timeout`
            });
        }, NETWORK_TIMEOUT);
    };
    send();
    /**
     * 监听 HTTP Response Header 事件。会比请求完成事件更早
     * @param {HeadersReceivedCallback} callback HTTP Response Header 事件的回调函数
     */
    const onHeadersReceived = callbackManager.headersReceived.add;
    /**
     * 取消监听 HTTP Response Header 事件
     * @param {HeadersReceivedCallback} callback HTTP Response Header 事件的回调函数
     */
    const offHeadersReceived = callbackManager.headersReceived.remove;
    /**
     * 监听进度变化事件
     * @param {ProgressUpdateCallback} callback HTTP Response Header 事件的回调函数
     */
    const onProgressUpdate = callbackManager.progressUpdate.add;
    /**
     * 取消监听进度变化事件
     * @param {ProgressUpdateCallback} callback HTTP Response Header 事件的回调函数
     */
    const offProgressUpdate = callbackManager.progressUpdate.remove;
    return {
        abort,
        onHeadersReceived,
        offHeadersReceived,
        onProgressUpdate,
        offProgressUpdate
    };
};
/**
 * 下载文件资源到本地。客户端直接发起一个 HTTPS GET 请求，返回文件的本地临时路径。使用前请注意阅读相关说明。
 * 注意：请在服务端响应的 header 中指定合理的 Content-Type 字段，以保证客户端正确处理文件类型。
 */
const downloadFile = ({ url, header, success, fail, complete }) => {
    let task;
    const result = new Promise((resolve, reject) => {
        task = createDownloadTask({
            url,
            header,
            success: res => {
                success && success(res);
                complete && complete(res);
                resolve(res);
            },
            error: res => {
                fail && fail(res);
                complete && complete(res);
                reject(res);
            }
        });
    });
    result.headersReceive = task.onHeadersReceived;
    result.progress = task.onProgressUpdate;
    result.abort = task.abort;
    return result;
};

// mDNS
const stopLocalServiceDiscovery = temporarilyNotSupport('stopLocalServiceDiscovery');
const startLocalServiceDiscovery = temporarilyNotSupport('startLocalServiceDiscovery');
const onLocalServiceResolveFail = temporarilyNotSupport('onLocalServiceResolveFail');
const onLocalServiceLost = temporarilyNotSupport('onLocalServiceLost');
const onLocalServiceFound = temporarilyNotSupport('onLocalServiceFound');
const onLocalServiceDiscoveryStop = temporarilyNotSupport('onLocalServiceDiscoveryStop');
const offLocalServiceResolveFail = temporarilyNotSupport('offLocalServiceResolveFail');
const offLocalServiceLost = temporarilyNotSupport('offLocalServiceLost');
const offLocalServiceFound = temporarilyNotSupport('offLocalServiceFound');
const offLocalServiceDiscoveryStop = temporarilyNotSupport('offLocalServiceDiscoveryStop');

// @ts-ignore
const { Link: Link$1 } = Taro__default["default"];
function generateRequestUrlWithParams(url, params) {
    params = typeof params === 'string' ? params : serializeParams(params);
    if (params) {
        url += (~url.indexOf('?') ? '&' : '?') + params;
    }
    url = url.replace('?&', '?');
    return url;
}
// FIXME 移除 any 标注
function _request(options) {
    options = options || {};
    if (typeof options === 'string') {
        options = {
            url: options
        };
    }
    const { success, complete, fail } = options;
    let url = options.url;
    const params = {};
    const res = {};
    if (options.jsonp) {
        Object.assign(params, options);
        params.params = options.data;
        params.cache = options.jsonpCache;
        if (typeof options.jsonp === 'string') {
            params.name = options.jsonp;
        }
        delete params.jsonp;
        return jsonpRetry__default["default"](url, params)
            .then(data => {
            res.statusCode = 200;
            res.data = data;
            typeof success === 'function' && success(res);
            typeof complete === 'function' && complete(res);
            return res;
        })
            .catch(err => {
            typeof fail === 'function' && fail(err);
            typeof complete === 'function' && complete(res);
            return Promise.reject(err);
        });
    }
    params.method = options.method || 'GET';
    const methodUpper = params.method.toUpperCase();
    params.cache = options.cache || 'default';
    if (methodUpper === 'GET' || methodUpper === 'HEAD') {
        url = generateRequestUrlWithParams(url, options.data);
    }
    else if (typeof options.data === 'object') {
        options.header = options.header || {};
        const keyOfContentType = Object.keys(options.header).find(item => item.toLowerCase() === 'content-type');
        if (!keyOfContentType) {
            options.header['Content-Type'] = 'application/json';
        }
        const contentType = options.header[keyOfContentType || 'Content-Type'];
        if (contentType.indexOf('application/json') >= 0) {
            params.body = JSON.stringify(options.data);
        }
        else if (contentType.indexOf('application/x-www-form-urlencoded') >= 0) {
            params.body = serializeParams(options.data);
        }
        else {
            params.body = options.data;
        }
    }
    else {
        params.body = options.data;
    }
    if (options.header) {
        params.headers = options.header;
    }
    if (options.mode) {
        params.mode = options.mode;
    }
    if (options.signal) {
        params.signal = options.signal;
    }
    params.credentials = options.credentials;
    return fetch(url, params)
        .then(response => {
        if (!response) {
            const errorResponse = { ok: false };
            throw errorResponse;
        }
        res.statusCode = response.status;
        res.header = {};
        for (const key of response.headers.keys()) {
            res.header[key] = response.headers.get(key);
        }
        if (!response.ok) {
            throw response;
        }
        if (options.responseType === 'arraybuffer') {
            return response.arrayBuffer();
        }
        if (res.statusCode !== 204) {
            if (options.dataType === 'json' || typeof options.dataType === 'undefined') {
                return response.json();
            }
        }
        if (options.responseType === 'text' || options.dataType === 'text') {
            return response.text();
        }
        return Promise.resolve(null);
    })
        .then(data => {
        res.data = data;
        typeof success === 'function' && success(res);
        typeof complete === 'function' && complete(res);
        return res;
    })
        .catch(err => {
        typeof fail === 'function' && fail(err);
        typeof complete === 'function' && complete(res);
        return Promise.reject(err);
    });
}
function taroInterceptor(chain) {
    return _request(chain.requestParams);
}
const link = new Link$1(taroInterceptor);
const request = link.request.bind(link);
const addInterceptor = link.addInterceptor.bind(link);

// TCP 通信
const createTCPSocket = temporarilyNotSupport('createTCPSocket');

// UDP 通信
const createUDPSocket = temporarilyNotSupport('createUDPSocket');

const createUploadTask = ({ url, filePath, formData = {}, name, header, timeout, fileName, success, error }) => {
    let timeoutInter;
    let formKey;
    const apiName = 'uploadFile';
    const xhr = new XMLHttpRequest();
    const form = new FormData();
    const callbackManager = {
        headersReceived: new CallbackManager(),
        progressUpdate: new CallbackManager()
    };
    xhr.open('POST', url);
    setHeader(xhr, header);
    for (formKey in formData) {
        form.append(formKey, formData[formKey]);
    }
    xhr.upload.onprogress = e => {
        const { loaded, total } = e;
        callbackManager.progressUpdate.trigger({
            progress: Math.round(loaded / total * 100),
            totalBytesSent: loaded,
            totalBytesExpectedToSent: total
        });
    };
    xhr.onreadystatechange = () => {
        if (xhr.readyState !== XHR_STATS.HEADERS_RECEIVED)
            return;
        callbackManager.headersReceived.trigger({
            header: xhr.getAllResponseHeaders()
        });
    };
    xhr.onload = () => {
        const status = xhr.status;
        clearTimeout(timeoutInter);
        success({
            errMsg: `${apiName}:ok`,
            statusCode: status,
            data: xhr.responseText || xhr.response
        });
    };
    xhr.onabort = () => {
        clearTimeout(timeoutInter);
        error({
            errMsg: `${apiName}:fail abort`
        });
    };
    xhr.onerror = (e) => {
        clearTimeout(timeoutInter);
        error({
            errMsg: `${apiName}:fail ${e.message}`
        });
    };
    /**
     * 中断任务
     */
    const abort = () => {
        clearTimeout(timeoutInter);
        xhr.abort();
    };
    const send = () => {
        xhr.send(form);
        timeoutInter = setTimeout(() => {
            xhr.onabort = null;
            xhr.onload = null;
            xhr.upload.onprogress = null;
            xhr.onreadystatechange = null;
            xhr.onerror = null;
            abort();
            error({
                errMsg: `${apiName}:fail timeout`
            });
        }, timeout || NETWORK_TIMEOUT);
    };
    convertObjectUrlToBlob(filePath)
        .then((fileObj) => {
        if (!fileName) {
            fileName = typeof fileObj !== 'string' && fileObj.name;
        }
        form.append(name, fileObj, fileName || `file-${Date.now()}`);
        send();
    })
        .catch(e => {
        error({
            errMsg: `${apiName}:fail ${e.message}`
        });
    });
    /**
     * 监听 HTTP Response Header 事件。会比请求完成事件更早
     * @param {HeadersReceivedCallback} callback HTTP Response Header 事件的回调函数
     */
    const onHeadersReceived = callbackManager.headersReceived.add;
    /**
     * 取消监听 HTTP Response Header 事件
     * @param {HeadersReceivedCallback} callback HTTP Response Header 事件的回调函数
     */
    const offHeadersReceived = callbackManager.headersReceived.remove;
    /**
     * 监听进度变化事件
     * @param {ProgressUpdateCallback} callback HTTP Response Header 事件的回调函数
     */
    const onProgressUpdate = callbackManager.progressUpdate.add;
    /**
     * 取消监听进度变化事件
     * @param {ProgressUpdateCallback} callback HTTP Response Header 事件的回调函数
     */
    const offProgressUpdate = callbackManager.progressUpdate.remove;
    return {
        abort,
        onHeadersReceived,
        offHeadersReceived,
        onProgressUpdate,
        offProgressUpdate
    };
};
/**
 * 将本地资源上传到服务器。客户端发起一个 HTTPS POST 请求，其中 content-type 为 multipart/form-data。使用前请注意阅读相关说明。
 */
const uploadFile = ({ url, filePath, name, header, formData, timeout, fileName, success, fail, complete }) => {
    let task;
    const result = new Promise((resolve, reject) => {
        task = createUploadTask({
            url,
            header,
            name,
            filePath,
            formData,
            timeout,
            fileName,
            success: res => {
                success && success(res);
                complete && complete(res);
                resolve(res);
            },
            error: res => {
                fail && fail(res);
                complete && complete(res);
                reject(res);
            }
        });
    });
    result.headersReceive = task.onHeadersReceived;
    result.progress = task.onProgressUpdate;
    result.abort = task.abort;
    return result;
};

class SocketTask {
    constructor(url, protocols) {
        if (protocols && protocols.length) {
            this.ws = new WebSocket(url, protocols);
        }
        else {
            this.ws = new WebSocket(url);
        }
        this.CONNECTING = 0;
        this.OPEN = 1;
        this.CLOSING = 2;
        this.CLOSED = 3;
    }
    get readyState() {
        return this.ws.readyState;
    }
    send(opts = {}) {
        if (typeof opts !== 'object' || !opts)
            opts = {};
        const { data = '', success, fail, complete } = opts;
        if (this.readyState !== 1) {
            const res = { errMsg: 'SocketTask.send:fail SocketTask.readState is not OPEN' };
            console.error(res.errMsg);
            typeof fail === 'function' && fail(res);
            typeof complete === 'function' && complete(res);
            return Promise.reject(res);
        }
        this.ws.send(data);
        const res = { errMsg: 'sendSocketMessage:ok' };
        typeof success === 'function' && success(res);
        typeof complete === 'function' && complete(res);
        return Promise.resolve(res);
    }
    close(opts = {}) {
        if (typeof opts !== 'object' || !opts)
            opts = {};
        const { code = 1000, reason = 'server complete,close', success, complete } = opts;
        this.closeDetail = { code, reason };
        // 主动断开时需要重置链接数
        this._destroyWhenClose && this._destroyWhenClose();
        this.ws.close();
        const res = { errMsg: 'closeSocket:ok' };
        typeof success === 'function' && success(res);
        typeof complete === 'function' && complete(res);
        return Promise.resolve(res);
    }
    onOpen(func) {
        this.ws.onopen = func;
    }
    onMessage(func) {
        this.ws.onmessage = func;
    }
    onClose(func) {
        this.ws.onclose = () => {
            // 若服务器方断掉也需要重置链接数
            this._destroyWhenClose && this._destroyWhenClose();
            func(this.closeDetail || { code: 1006, reason: 'abnormal closure' });
        };
    }
    onError(func) {
        this.ws.onerror = func;
    }
}

let socketTasks = [];
let socketsCounter = 1;
function sendSocketMessage() {
    console.warn('Deprecated.Please use socketTask.send instead.');
}
function onSocketOpen() {
    console.warn('Deprecated.Please use socketTask.onOpen instead.');
}
function onSocketMessage() {
    console.warn('Deprecated.Please use socketTask.onMessage instead.');
}
function onSocketError() {
    console.warn('Deprecated.Please use socketTask.onError instead.');
}
function onSocketClose() {
    console.warn('Deprecated.Please use socketTask.onClose instead.');
}
function connectSocket(options) {
    const name = 'connectSocket';
    return new Promise((resolve, reject) => {
        // options must be an Object
        const isObject = shouldBeObject(options);
        if (!isObject.flag) {
            const res = { errMsg: `${name}:fail ${isObject.msg}` };
            console.error(res.errMsg);
            return reject(res);
        }
        const { url, protocols, success, fail, complete } = options;
        const handle = new MethodHandler({ name, success, fail, complete });
        // options.url must be String
        if (typeof url !== 'string') {
            return handle.fail({
                errMsg: getParameterError({
                    para: 'url',
                    correct: 'String',
                    wrong: url
                })
            }, reject);
        }
        // options.url must be invalid
        if (!url.startsWith('ws://') && !url.startsWith('wss://')) {
            return handle.fail({
                errMsg: `request:fail invalid url "${url}"`
            }, reject);
        }
        // protocols must be array
        const _protocols = Array.isArray(protocols) ? protocols : null;
        // 2 connection at most
        if (socketTasks.length > 1) {
            return handle.fail({
                errMsg: '同时最多发起 2 个 socket 请求，更多请参考文档。'
            }, reject);
        }
        const task = new SocketTask(url, _protocols);
        task._destroyWhenClose = function () {
            socketTasks = socketTasks.filter(socketTask => socketTask !== this);
        };
        socketTasks.push(task);
        handle.success({
            socketTaskId: socketsCounter++
        });
        return resolve(task);
    });
}
function closeSocket() {
    console.warn('Deprecated.Please use socketTask.close instead.');
}

// 帐号信息
const getAccountInfoSync = temporarilyNotSupport('getAccountInfoSync');

// 收货地址
const chooseAddress = temporarilyNotSupport('chooseAddress');

// 授权
const authorizeForMiniProgram = temporarilyNotSupport('authorizeForMiniProgram');
const authorize = temporarilyNotSupport('authorize');

// 卡券
const openCard = temporarilyNotSupport('openCard');
const addCard = temporarilyNotSupport('addCard');

// 视频号
const reserveChannelsLive = temporarilyNotSupport('reserveChannelsLive');
const openChannelsLive = temporarilyNotSupport('openChannelsLive');
const openChannelsEvent = temporarilyNotSupport('openChannelsEvent');
const openChannelsActivity = temporarilyNotSupport('openChannelsActivity');
const getChannelsLiveNoticeInfo = temporarilyNotSupport('getChannelsLiveNoticeInfo');
const getChannelsLiveInfo = temporarilyNotSupport('getChannelsLiveInfo');

// 微信客服
const openCustomerServiceChat = temporarilyNotSupport('openCustomerServiceChat');

// 过往接口
const checkIsSupportFacialRecognition = temporarilyNotSupport('checkIsSupportFacialRecognition');
const startFacialRecognitionVerify = temporarilyNotSupport('startFacialRecognitionVerify');
const startFacialRecognitionVerifyAndUploadVideo = temporarilyNotSupport('startFacialRecognitionVerifyAndUploadVideo');
const faceVerifyForPay = temporarilyNotSupport('faceVerifyForPay');

// 收藏
const addVideoToFavorites = temporarilyNotSupport('addVideoToFavorites');
const addFileToFavorites = temporarilyNotSupport('addFileToFavorites');

// 微信群
const getGroupEnterInfo = temporarilyNotSupport('getGroupEnterInfo');

// 发票
const chooseInvoiceTitle = temporarilyNotSupport('chooseInvoiceTitle');
const chooseInvoice = temporarilyNotSupport('chooseInvoice');

// 车牌
const chooseLicensePlate = temporarilyNotSupport('chooseLicensePlate');

// 帐号信息
const pluginLogin = temporarilyNotSupport('pluginLogin');
const login = temporarilyNotSupport('login');
const checkSession = temporarilyNotSupport('checkSession');

// 微信红包
const showRedPackage = temporarilyNotSupport('showRedPackage');

// 设置
const openSetting = temporarilyNotSupport('openSetting');
const getSetting = temporarilyNotSupport('getSetting');

// 生物认证
const startSoterAuthentication = temporarilyNotSupport('startSoterAuthentication');
const checkIsSupportSoterAuthentication = temporarilyNotSupport('checkIsSupportSoterAuthentication');
const checkIsSoterEnrolledInDevice = temporarilyNotSupport('checkIsSoterEnrolledInDevice');

// 订阅消息
const requestSubscribeMessage = temporarilyNotSupport('requestSubscribeMessage');

// 用户信息
const getUserProfile = temporarilyNotSupport('getUserProfile');
const getUserInfo = temporarilyNotSupport('getUserInfo');

// 微信运动
const shareToWeRun = temporarilyNotSupport('shareToWeRun');
const getWeRunData = temporarilyNotSupport('getWeRunData');

// 支付
const requestPayment = temporarilyNotSupport('requestPayment');
const requestOrderPayment = temporarilyNotSupport('requestOrderPayment');

// 路由
// FIXME 方法导出类型未对齐，后续修复

// 转发
const updateShareMenu = temporarilyNotSupport('updateShareMenu');
const showShareMenu = temporarilyNotSupport('showShareMenu');
const showShareImageMenu = temporarilyNotSupport('showShareImageMenu');
const shareVideoMessage = temporarilyNotSupport('shareVideoMessage');
const shareFileMessage = temporarilyNotSupport('shareFileMessage');
const onCopyUrl = temporarilyNotSupport('onCopyUrl');
const offCopyUrl = temporarilyNotSupport('offCopyUrl');
const hideShareMenu = temporarilyNotSupport('hideShareMenu');
const getShareInfo = temporarilyNotSupport('getShareInfo');
const authPrivateMessage = temporarilyNotSupport('authPrivateMessage');

/**
 * H5 下的 styleSheet 操作
 * @author leeenx
 */
class StyleSheet {
    constructor() {
        this.$style = null;
        this.sheet = null;
        this.appendStyleSheet = () => {
            if (this.$style) {
                const head = document.getElementsByTagName('head')[0];
                this.$style.setAttribute('type', 'text/css');
                this.$style.setAttribute('data-type', 'Taro');
                head.appendChild(this.$style);
                this.sheet = this.$style.sheet;
            }
            if (this.sheet && !('insertRule' in this.sheet)) {
                console.warn('当前浏览器不支持 stylesheet.insertRule 接口');
            }
        };
        // 添加样式命令
        this.add = (cssText, index = 0) => {
            var _a;
            if (this.sheet === null) {
                // $style 未插入到 DOM
                this.appendStyleSheet();
            }
            (_a = this.sheet) === null || _a === void 0 ? void 0 : _a.insertRule(cssText, index);
        };
        this.$style = document.createElement('style');
    }
}
const styleSheet = new StyleSheet();
// 监听事件
let TRANSITION_END = 'transitionend';
let TRANSFORM = 'transform';
const $detect = document.createElement('div');
$detect.style.cssText = '-webkit-animation-name:webkit;-moz-animation-name:moz;-ms-animation-name:ms;animation-name:standard;';
if ($detect.style['animation-name'] === 'standard') {
    // 支持标准写法
    TRANSITION_END = 'transitionend';
    TRANSFORM = 'transform';
}
else if ($detect.style['-webkit-animation-name'] === 'webkit') {
    // webkit 前缀
    TRANSITION_END = 'webkitTransitionEnd';
    TRANSFORM = '-webkit-transform';
}
else if ($detect.style['-moz-animation-name'] === 'moz') {
    // moz 前缀
    TRANSITION_END = 'mozTransitionEnd';
    TRANSFORM = '-moz-transform';
}
else if ($detect.style['-ms-animation-name'] === 'ms') {
    // ms 前缀
    TRANSITION_END = 'msTransitionEnd';
    TRANSFORM = '-ms-transform';
}
let animId = 0;
class Animation {
    constructor({ duration = 400, delay = 0, timingFunction = 'linear', transformOrigin = '50% 50% 0', unit = 'px' } = {}) {
        // 属性组合
        this.rules = [];
        // transform 对象
        this.transform = [`${TRANSFORM}:`];
        // 组合动画
        this.steps = [];
        // 动画 map ----- 永久保留
        this.animationMap = {};
        // animationMap 的长度
        this.animationMapCount = 0;
        // 默认值
        this.setDefault(duration, delay, timingFunction, transformOrigin);
        this.unit = unit;
        // atom 环境下，animation 属性不会显示，所以要改成 data-animation
        let animAttr = 'animation';
        // 动画 id
        this.id = ++animId;
        // 监听事件
        document.body.addEventListener(TRANSITION_END, (e) => {
            const target = e.target;
            if (target.getAttribute(animAttr) === null) {
                animAttr = 'data-animation';
            }
            const animData = target.getAttribute(animAttr);
            // 没有动画存在
            if (animData === null)
                return;
            const [animName, animPath] = animData.split('__');
            if (animName === `taro-h5-poly-fill/${this.id}/create-animation`) {
                const [animIndex, __stepIndex = 0] = animPath.split('--');
                const stepIndex = Number(__stepIndex);
                // 动画总的关键帧
                const animStepsCount = this.animationMap[`${animName}__${animIndex}`];
                const animStepsMaxIndex = animStepsCount - 1;
                if (stepIndex < animStepsMaxIndex) {
                    // 播放下一个关键帧（因为 nerv 和 react 有差异所以 animation & data-animation 都需要写）
                    target.setAttribute(animAttr, `${animName}__${animIndex}--${stepIndex + 1}`);
                    if (animAttr === 'animation') {
                        // Nerv 环境，animation & data-animation 双重保险
                        target.setAttribute('data-animation', `${animName}__${animIndex}--${stepIndex + 1}`);
                    }
                }
            }
        });
    }
    transformUnit(...args) {
        const ret = [];
        args.forEach(each => {
            ret.push(isNaN(each) ? each : `${each}${this.unit}`);
        });
        return ret;
    }
    // 设置默认值
    setDefault(duration, delay, timingFunction, transformOrigin) {
        this.DEFAULT = { duration, delay, timingFunction, transformOrigin };
    }
    matrix(a, b, c, d, tx, ty) {
        this.transform.push(`matrix(${a}, ${b}, ${c}, ${d}, ${tx}, ${ty})`);
        return this;
    }
    matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4) {
        this.transform.push(`matrix3d(${a1}, ${b1}, ${c1}, ${d1}, ${a2}, ${b2}, ${c2}, ${d2}, ${a3}, ${b3}, ${c3}, ${d3}, ${a4}, ${b4}, ${c4}, ${d4})`);
        return this;
    }
    rotate(angle) {
        this.transform.push(`rotate(${angle}deg)`);
        return this;
    }
    rotate3d(x, y, z, angle) {
        if (typeof y !== 'number') {
            this.transform.push(`rotate3d(${x})`);
        }
        else {
            this.transform.push(`rotate3d(${x}, ${y || 0}, ${z || 0}, ${angle || 0}deg)`);
        }
        return this;
    }
    rotateX(angle) {
        this.transform.push(`rotateX(${angle}deg)`);
        return this;
    }
    rotateY(angle) {
        this.transform.push(`rotateY(${angle}deg)`);
        return this;
    }
    rotateZ(angle) {
        this.transform.push(`rotateZ(${angle}deg)`);
        return this;
    }
    scale(x, y) {
        this.transform.push(`scale(${x}, ${y})`);
        return this;
    }
    scale3d(x, y, z) {
        this.transform.push(`scale3d(${x}, ${y}, ${z})`);
        return this;
    }
    scaleX(scale) {
        this.transform.push(`scaleX(${scale})`);
        return this;
    }
    scaleY(scale) {
        this.transform.push(`scaleY(${scale})`);
        return this;
    }
    scaleZ(scale) {
        this.transform.push(`scaleZ(${scale})`);
        return this;
    }
    skew(x, y) {
        this.transform.push(`skew(${x}, ${y})`);
        return this;
    }
    skewX(angle) {
        this.transform.push(`skewX(${angle})`);
        return this;
    }
    skewY(angle) {
        this.transform.push(`skewY(${angle})`);
        return this;
    }
    translate(x, y) {
        [x, y] = this.transformUnit(x, y);
        this.transform.push(`translate(${x}, ${y})`);
        return this;
    }
    translate3d(x, y, z) {
        [x, y, z] = this.transformUnit(x, y, z);
        this.transform.push(`translate3d(${x}, ${y}, ${z})`);
        return this;
    }
    translateX(translate) {
        [translate] = this.transformUnit(translate);
        this.transform.push(`translateX(${translate})`);
        return this;
    }
    translateY(translate) {
        [translate] = this.transformUnit(translate);
        this.transform.push(`translateY(${translate})`);
        return this;
    }
    translateZ(translate) {
        [translate] = this.transformUnit(translate);
        this.transform.push(`translateZ(${translate})`);
        return this;
    }
    opacity(value) {
        this.rules.push(`opacity: ${value}`);
        return this;
    }
    backgroundColor(value) {
        this.rules.push(`background-color: ${value}`);
        return this;
    }
    width(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`width: ${value}`);
        return this;
    }
    height(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`height: ${value}`);
        return this;
    }
    top(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`top: ${value}`);
        return this;
    }
    right(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`right: ${value}`);
        return this;
    }
    bottom(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`bottom: ${value}`);
        return this;
    }
    left(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`left: ${value}`);
        return this;
    }
    // 关键帧载入
    step(arg = {}) {
        const { DEFAULT } = this;
        const { duration = DEFAULT.duration, delay = DEFAULT.delay, timingFunction = DEFAULT.timingFunction, transformOrigin = DEFAULT.transformOrigin } = arg;
        // 生成一条 transition 动画
        this.steps.push([
            this.rules.map(rule => `${rule}!important`).join(';'),
            `${this.transform.join(' ')}!important`,
            `${TRANSFORM}-origin: ${transformOrigin}`,
            `transition: all ${duration}ms ${timingFunction} ${delay}ms`
        ]
            .filter(item => item !== '' && item !== `${TRANSFORM}:`)
            .join(';'));
        // 清空 rules 和 transform
        this.rules = [];
        this.transform = [`${TRANSFORM}:`];
        return this;
    }
    // 创建底层数据
    createAnimationData() {
        const animIndex = `taro-h5-poly-fill/${this.id}/create-animation__${this.animationMapCount++}`;
        // 记录动画分几个 step
        this.animationMap[animIndex] = this.steps.length;
        // 吐出 step
        this.steps.forEach((step, index) => {
            const selector = index === 0
                ? `[animation="${animIndex}"], [data-animation="${animIndex}"]`
                : `[animation="${animIndex}--${index}"], [data-animation="${animIndex}--${index}"]`;
            styleSheet.add(`${selector} { ${step} }`);
        });
        // 清空 steps
        this.steps = [];
        return animIndex;
    }
    // 动画数据产出
    export() {
        return this.createAnimationData();
    }
}
// h5 的 createAnimation
const createAnimation = (option) => {
    return new Animation(option);
};

// 背景
const setBackgroundTextStyle = temporarilyNotSupport('setBackgroundTextStyle');
const setBackgroundColor = temporarilyNotSupport('setBackgroundColor');

// 自定义组件
const nextTick = Taro__default["default"].nextTick;

// 字体
const loadFontFace = async (options) => {
    options = Object.assign({ global: false }, options);
    const { success, fail, complete, family, source, desc = {} } = options;
    const handle = new MethodHandler({ name: 'loadFontFace', success, fail, complete });
    // @ts-ignore
    const fonts = document.fonts;
    if (fonts) {
        // @ts-ignore
        const fontFace = new FontFace(family, source, desc);
        try {
            await fontFace.load();
            fonts.add(fontFace);
            return handle.success({});
        }
        catch (error) {
            return handle.fail({
                errMsg: error.message || error
            });
        }
    }
    else {
        const style = document.createElement('style');
        let innerText = `font-family:"${family}";src:${source};font-style:${desc.style || 'normal'};font-weight:${desc.weight || 'normal'};font-variant:${desc.variant || 'normal'};`;
        if (desc.ascentOverride) {
            innerText += `ascent-override:${desc.ascentOverride};`;
        }
        if (desc.descentOverride) {
            innerText += `descent-override:${desc.descentOverride};`;
        }
        if (desc.featureSettings) {
            innerText += `font-feature-settings:${desc.featureSettings};`;
        }
        if (desc.lineGapOverride) {
            innerText += `line-gap-override:${desc.lineGapOverride};`;
        }
        if (desc.stretch) {
            innerText += `font-stretch:${desc.stretch};`;
        }
        if (desc.unicodeRange) {
            innerText += `unicode-range:${desc.unicodeRange};`;
        }
        if (desc.variationSettings) {
            innerText += `font-variation-settings:${desc.variationSettings};`;
        }
        style.innerText = `@font-face{${innerText}}`;
        document.head.appendChild(style);
        return handle.success();
    }
};

// 菜单
const getMenuButtonBoundingClientRect = temporarilyNotSupport('getMenuButtonBoundingClientRect');

// 导航栏
const showNavigationBarLoading = temporarilyNotSupport('showNavigationBarLoading');
function setNavigationBarTitle(options) {
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `setNavigationBarTitle:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { title, success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'setNavigationBarTitle', success, fail, complete });
    if (!title || typeof title !== 'string') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'title',
                correct: 'String',
                wrong: title
            })
        });
    }
    if (document.title !== title) {
        document.title = title;
    }
    return handle.success();
}
/**
 * 设置页面导航条颜色
 */
const setNavigationBarColor = (options) => {
    const { backgroundColor, success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'setNavigationBarColor', success, fail, complete });
    const meta = document.createElement('meta');
    meta.setAttribute('name', 'theme-color');
    meta.setAttribute('content', backgroundColor);
    document.head.appendChild(meta);
    return handle.success();
};
const hideNavigationBarLoading = temporarilyNotSupport('hideNavigationBarLoading');
const hideHomeButton = temporarilyNotSupport('hideHomeButton');

/**
 * 开始下拉刷新。调用后触发下拉刷新动画，效果与用户手动下拉刷新一致。
 */
const startPullDownRefresh = function ({ success, fail, complete } = {}) {
    const handle = new MethodHandler({ name: 'startPullDownRefresh', success, fail, complete });
    return new Promise((resolve, reject) => {
        Taro__default["default"].eventCenter.trigger('__taroStartPullDownRefresh', {
            successHandler: (res = {}) => handle.success(res, resolve),
            errorHandler: (res = {}) => handle.fail(res, reject)
        });
    });
};
/**
 * 停止当前页面下拉刷新。
 */
const stopPullDownRefresh = function ({ success, fail, complete } = {}) {
    const handle = new MethodHandler({ name: 'stopPullDownRefresh', success, fail, complete });
    return new Promise((resolve, reject) => {
        Taro__default["default"].eventCenter.trigger('__taroStopPullDownRefresh', {
            successHandler: (res = {}) => handle.success(res, resolve),
            errorHandler: (res = {}) => handle.fail(res, reject)
        });
    });
};

let timer;
const FRAME_DURATION = 17;
/**
 * 将页面滚动到目标位置
 */
const pageScrollTo = ({ scrollTop, selector = '', duration = 300, success, fail, complete }) => {
    let scrollFunc;
    const handle = new MethodHandler({ name: 'pageScrollTo', success, fail, complete });
    return new Promise((resolve, reject) => {
        var _a, _b;
        try {
            if (scrollTop === undefined && !selector) {
                return handle.fail({
                    errMsg: 'scrollTop" 或 "selector" 需要其之一'
                }, reject);
            }
            const id = (_b = (_a = runtime.Current.page) === null || _a === void 0 ? void 0 : _a.path) === null || _b === void 0 ? void 0 : _b.replace(/([^a-z0-9\u00a0-\uffff_-])/ig, '\\$1');
            const el = (id
                ? document.querySelector(`.taro_page#${id}`)
                : document.querySelector('.taro_page') ||
                    document.querySelector('.taro_router'));
            if (!scrollFunc) {
                if (!el) {
                    scrollFunc = pos => {
                        if (pos === undefined) {
                            return window.pageYOffset;
                        }
                        else {
                            window.scrollTo(0, pos);
                        }
                    };
                }
                else {
                    scrollFunc = pos => {
                        if (pos === undefined) {
                            return el.scrollTop;
                        }
                        else {
                            el.scrollTop = pos;
                        }
                    };
                }
            }
            if (scrollTop && selector) {
                console.warn('"scrollTop" 或 "selector" 建议只设一个值，全部设置会忽略selector');
            }
            const from = scrollFunc();
            let to;
            if (typeof scrollTop === 'number') {
                to = scrollTop;
            }
            else {
                const el = document.querySelector(selector);
                to = (el === null || el === void 0 ? void 0 : el.offsetTop) || 0;
            }
            const delta = to - from;
            const frameCnt = duration / FRAME_DURATION;
            const easeFunc = getTimingFunc(easeInOut, frameCnt);
            const scroll = (frame = 0) => {
                const dest = from + delta * easeFunc(frame);
                scrollFunc(dest);
                if (frame < frameCnt) {
                    timer && clearTimeout(timer);
                    timer = setTimeout(() => {
                        scroll(frame + 1);
                    }, FRAME_DURATION);
                }
                else {
                    return handle.success({}, resolve);
                }
            };
            scroll();
        }
        catch (e) {
            return handle.fail({
                errMsg: e.message
            }, reject);
        }
    });
};

// 置顶
const setTopBarText = temporarilyNotSupport('setTopBarText');

let tabConf;
function initTabBarApis(config = {}) {
    tabConf = config.tabBar;
}
/**
 * 显示 tabBar 某一项的右上角的红点
 */
const showTabBarRedDot = (options) => {
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `showTabBarRedDot:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index, success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'showTabBarRedDot', success, fail, complete });
    if (typeof index !== 'number') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'index',
                correct: 'Number',
                wrong: index
            })
        });
    }
    return new Promise((resolve, reject) => {
        Taro__default["default"].eventCenter.trigger('__taroShowTabBarRedDotHandler', {
            index,
            successHandler: (res = {}) => handle.success(res, resolve),
            errorHandler: (res = {}) => handle.fail(res, reject)
        });
    });
};
/**
 * 显示 tabBar
 */
const showTabBar = (options = {}) => {
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `showTabBar:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { animation, success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'showTabBar', success, fail, complete });
    if (options.hasOwnProperty('animation') && typeof animation !== 'boolean') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'animation',
                correct: 'Boolean',
                wrong: animation
            })
        });
    }
    return new Promise((resolve, reject) => {
        Taro__default["default"].eventCenter.trigger('__taroShowTabBar', {
            animation,
            successHandler: (res = {}) => handle.success(res, resolve),
            errorHandler: (res = {}) => handle.fail(res, reject)
        });
    });
};
/**
 * 动态设置 tabBar 的整体样式
 */
const setTabBarStyle = (options = {}) => {
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `setTabBarStyle:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { color, selectedColor, backgroundColor, borderStyle, success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'setTabBarStyle', success, fail, complete });
    let errMsg;
    if (color && !isValidColor(color)) {
        errMsg = 'color';
    }
    else if (selectedColor && !isValidColor(selectedColor)) {
        errMsg = 'selectedColor';
    }
    else if (backgroundColor && !isValidColor(backgroundColor)) {
        errMsg = 'backgroundColor';
    }
    else if (borderStyle && !/^(black|white)$/.test(borderStyle)) {
        errMsg = 'borderStyle';
    }
    if (errMsg) {
        return handle.fail({ errMsg: `invalid ${errMsg}` });
    }
    if (!tabConf) {
        return handle.fail();
    }
    const obj = {};
    if (color)
        obj.color = color;
    if (selectedColor)
        obj.selectedColor = selectedColor;
    if (backgroundColor)
        obj.backgroundColor = backgroundColor;
    if (borderStyle)
        obj.borderStyle = borderStyle;
    return new Promise((resolve, reject) => {
        Taro__default["default"].eventCenter.trigger('__taroSetTabBarStyle', {
            color,
            selectedColor,
            backgroundColor,
            borderStyle,
            successHandler: (res = {}) => handle.success(res, resolve),
            errorHandler: (res = {}) => handle.fail(res, reject)
        });
    });
};
/**
 * 动态设置 tabBar 某一项的内容
 */
const setTabBarItem = (options) => {
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `setTabBarItem:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index, text, iconPath, selectedIconPath, success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'setTabBarItem', success, fail, complete });
    if (typeof index !== 'number') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'index',
                correct: 'Number',
                wrong: index
            })
        });
    }
    return new Promise((resolve, reject) => {
        Taro__default["default"].eventCenter.trigger('__taroSetTabBarItem', {
            index,
            text,
            iconPath,
            selectedIconPath,
            successHandler: (res = {}) => handle.success(res, resolve),
            errorHandler: (res = {}) => handle.fail(res, reject)
        });
    });
};
/**
 * 为 tabBar 某一项的右上角添加文本
 */
const setTabBarBadge = (options) => {
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `setTabBarBadge:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index, text, success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'setTabBarBadge', success, fail, complete });
    if (typeof index !== 'number') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'index',
                correct: 'Number',
                wrong: index
            })
        });
    }
    if (typeof text !== 'string') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'text',
                correct: 'String',
                wrong: text
            })
        });
    }
    return new Promise((resolve, reject) => {
        Taro__default["default"].eventCenter.trigger('__taroSetTabBarBadge', {
            index,
            text,
            successHandler: (res = {}) => handle.success(res, resolve),
            errorHandler: (res = {}) => handle.fail(res, reject)
        });
    });
};
/**
 * 移除 tabBar 某一项右上角的文本
 */
const removeTabBarBadge = (options) => {
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `removeTabBarBadge:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index, success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'removeTabBarBadge', success, fail, complete });
    if (typeof index !== 'number') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'index',
                correct: 'Number',
                wrong: index
            })
        });
    }
    return new Promise((resolve, reject) => {
        Taro__default["default"].eventCenter.trigger('__taroRemoveTabBarBadge', {
            index,
            successHandler: (res = {}) => handle.success(res, resolve),
            errorHandler: (res = {}) => handle.fail(res, reject)
        });
    });
};
/**
 * 隐藏 tabBar 某一项的右上角的红点
 */
const hideTabBarRedDot = (options) => {
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `hideTabBarRedDot:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index, success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'hideTabBarRedDot', success, fail, complete });
    if (typeof index !== 'number') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'index',
                correct: 'Number',
                wrong: index
            })
        });
    }
    return new Promise((resolve, reject) => {
        Taro__default["default"].eventCenter.trigger('__taroHideTabBarRedDotHandler', {
            index,
            successHandler: (res = {}) => handle.success(res, resolve),
            errorHandler: (res = {}) => handle.fail(res, reject)
        });
    });
};
/**
 * 隐藏 tabBar
 */
const hideTabBar = (options = {}) => {
    // options must be an Object
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `hideTabBar:fail ${isObject.msg}` };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { animation, success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'hideTabBar', success, fail, complete });
    if (options.hasOwnProperty('animation') && typeof animation !== 'boolean') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'animation',
                correct: 'Boolean',
                wrong: animation
            })
        });
    }
    return new Promise((resolve, reject) => {
        Taro__default["default"].eventCenter.trigger('__taroHideTabBar', {
            animation,
            successHandler: (res = {}) => handle.success(res, resolve),
            errorHandler: (res = {}) => handle.fail(res, reject)
        });
    });
};

const callbackManager = new CallbackManager();
const resizeListener = () => {
    callbackManager.trigger({
        windowWidth: window.screen.width,
        windowHeight: window.screen.height
    });
};
/**
 * 设置窗口大小，该接口仅适用于 PC 平台，使用细则请参见指南
 */
const setWindowSize = temporarilyNotSupport('setWindowSize');
/**
 * 监听窗口尺寸变化事件
 */
const onWindowResize = callback => {
    callbackManager.add(callback);
    if (callbackManager.count() === 1) {
        window.addEventListener('resize', resizeListener);
    }
};
/**
 * 取消监听窗口尺寸变化事件
 */
const offWindowResize = callback => {
    callbackManager.remove(callback);
    if (callbackManager.count() === 0) {
        window.removeEventListener('resize', resizeListener);
    }
};

class Toast {
    constructor() {
        this.options = {
            title: '',
            icon: 'none',
            image: '',
            duration: 1500,
            mask: false
        };
        this.style = {
            maskStyle: {
                position: 'fixed',
                'z-index': '1000',
                top: '0',
                right: '0',
                left: '0',
                bottom: '0'
            },
            toastStyle: {
                'z-index': '5000',
                'box-sizing': 'border-box',
                display: 'flex',
                'flex-direction': 'column',
                'justify-content': 'center',
                '-webkit-justify-content': 'center',
                position: 'fixed',
                top: '50%',
                left: '50%',
                'min-width': '120px',
                'max-width': '200px',
                'min-height': '120px',
                padding: '15px',
                transform: 'translate(-50%, -50%)',
                'border-radius': '5px',
                'text-align': 'center',
                'line-height': '1.6',
                color: '#FFFFFF',
                background: 'rgba(17, 17, 17, 0.7)'
            },
            successStyle: {
                margin: '6px auto',
                width: '38px',
                height: '38px',
                background: 'transparent url(data:image/svg+xml;base64,PHN2ZyB0PSIxNjM5NTQ4OTYzMjA0IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjQzNDgiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48cGF0aCBkPSJNMjE5Ljk1MiA1MTIuNTc2bDIxMC40MzIgMjEwLjQzMi00NS4yNDggNDUuMjU2LTIxMC40MzItMjEwLjQzMnoiIHAtaWQ9IjQzNDkiIGZpbGw9IiNmZmZmZmYiPjwvcGF0aD48cGF0aCBkPSJNNzk5LjY3MiAyNjIuMjY0bDQ1LjI1NiA0NS4yNTYtNDYwLjQ2NCA0NjAuNDY0LTQ1LjI1Ni00NS4yNTZ6IiBwLWlkPSI0MzUwIiBmaWxsPSIjZmZmZmZmIj48L3BhdGg+PC9zdmc+) no-repeat',
                'background-size': '100%'
            },
            errrorStyle: {
                margin: '6px auto',
                width: '38px',
                height: '38px',
                background: 'transparent url(data:image/svg+xml;base64,PHN2ZyB0PSIxNjM5NTUxMDU1MTgzIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjE0MDc2IiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PHBhdGggZD0iTTUxMiA2NEMyNjQuNTggNjQgNjQgMjY0LjU4IDY0IDUxMnMyMDAuNTggNDQ4IDQ0OCA0NDggNDQ4LTIwMC41OCA0NDgtNDQ4Uzc1OS40MiA2NCA1MTIgNjR6IG0wIDc1MmEzNiAzNiAwIDEgMSAzNi0zNiAzNiAzNiAwIDAgMS0zNiAzNnogbTUxLjgzLTU1MS45NUw1NDggNjM2YTM2IDM2IDAgMCAxLTcyIDBsLTE1LjgzLTM3MS45NWMtMC4xLTEuMzMtMC4xNy0yLjY4LTAuMTctNC4wNWE1MiA1MiAwIDAgMSAxMDQgMGMwIDEuMzctMC4wNyAyLjcyLTAuMTcgNC4wNXoiIHAtaWQ9IjE0MDc3IiBmaWxsPSIjZmZmZmZmIj48L3BhdGg+PC9zdmc+) no-repeat',
                'background-size': '100%'
            },
            loadingStyle: {
                margin: '6px auto',
                width: '38px',
                height: '38px',
                '-webkit-animation': 'taroLoading 1s steps(12, end) infinite',
                animation: 'taroLoading 1s steps(12, end) infinite',
                background: 'transparent url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTIwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHBhdGggZmlsbD0ibm9uZSIgZD0iTTAgMGgxMDB2MTAwSDB6Ii8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjRTlFOUU5IiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgLTMwKSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iIzk4OTY5NyIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzMCAxMDUuOTggNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjOUI5OTlBIiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKDYwIDc1Ljk4IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0EzQTFBMiIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSg5MCA2NSA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNBQkE5QUEiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoMTIwIDU4LjY2IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0IyQjJCMiIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgxNTAgNTQuMDIgNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjQkFCOEI5IiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKDE4MCA1MCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNDMkMwQzEiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTE1MCA0NS45OCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNDQkNCQ0IiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTEyMCA0MS4zNCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNEMkQyRDIiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTkwIDM1IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0RBREFEQSIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgtNjAgMjQuMDIgNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjRTJFMkUyIiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKC0zMCAtNS45OCA2NSkiLz48L3N2Zz4=) no-repeat',
                'background-size': '100%'
            },
            imageStyle: {
                margin: '6px auto',
                width: '40px',
                height: '40px',
                background: 'transparent no-repeat',
                'background-size': '100%'
            },
            textStyle: {
                margin: '0',
                'font-size': '16px'
            }
        };
    }
    create(options = {}, _type = 'toast') {
        // style
        const { maskStyle, toastStyle, successStyle, errrorStyle, loadingStyle, imageStyle, textStyle } = this.style;
        // configuration
        const config = {
            ...this.options,
            ...options,
            _type
        };
        // wrapper
        this.el = document.createElement('div');
        this.el.className = 'taro__toast';
        this.el.style.opacity = '0';
        this.el.style.transition = 'opacity 0.1s linear';
        // mask
        this.mask = document.createElement('div');
        this.mask.setAttribute('style', inlineStyle(maskStyle));
        this.mask.style.display = config.mask ? 'block' : 'none';
        // icon
        this.icon = document.createElement('p');
        if (config.image) {
            this.icon.setAttribute('style', inlineStyle({
                ...imageStyle,
                'background-image': `url(${config.image})`
            }));
        }
        else {
            const iconStyle = config.icon === 'loading' ? loadingStyle : config.icon === 'error' ? errrorStyle : successStyle;
            this.icon.setAttribute('style', inlineStyle({
                ...iconStyle,
                ...(config.icon === 'none' ? { display: 'none' } : {})
            }));
        }
        // toast
        this.toast = document.createElement('div');
        this.toast.setAttribute('style', inlineStyle({
            ...toastStyle,
            ...(config.icon === 'none' ? {
                'min-height': '0',
                padding: '10px 15px'
            } : {})
        }));
        // title
        this.title = document.createElement('p');
        this.title.setAttribute('style', inlineStyle(textStyle));
        this.title.textContent = config.title;
        // result
        this.toast.appendChild(this.icon);
        this.toast.appendChild(this.title);
        this.el.appendChild(this.mask);
        this.el.appendChild(this.toast);
        // show immediately
        document.body.appendChild(this.el);
        setTimeout(() => { this.el.style.opacity = '1'; }, 0);
        this.type = config._type;
        // disappear after duration
        config.duration >= 0 && this.hide(config.duration, this.type);
        return '';
    }
    show(options = {}, _type = 'toast') {
        const config = {
            ...this.options,
            ...options,
            _type
        };
        if (this.hideOpacityTimer)
            clearTimeout(this.hideOpacityTimer);
        if (this.hideDisplayTimer)
            clearTimeout(this.hideDisplayTimer);
        // title
        this.title.textContent = config.title || '';
        // mask
        this.mask.style.display = config.mask ? 'block' : 'none';
        // image
        const { toastStyle, successStyle, errrorStyle, loadingStyle, imageStyle } = this.style;
        if (config.image) {
            this.icon.setAttribute('style', inlineStyle({
                ...imageStyle,
                'background-image': `url(${config.image})`
            }));
        }
        else {
            if (!config.image && config.icon) {
                const iconStyle = config.icon === 'loading' ? loadingStyle : config.icon === 'error' ? errrorStyle : successStyle;
                this.icon.setAttribute('style', inlineStyle({
                    ...iconStyle,
                    ...(config.icon === 'none' ? { display: 'none' } : {})
                }));
            }
        }
        // toast
        this.toast.setAttribute('style', inlineStyle({
            ...toastStyle,
            ...(config.icon === 'none' ? {
                'min-height': '0',
                padding: '10px 15px'
            } : {})
        }));
        // show
        this.el.style.display = 'block';
        setTimeout(() => { this.el.style.opacity = '1'; }, 0);
        this.type = config._type;
        // disappear after duration
        config.duration >= 0 && this.hide(config.duration, this.type);
        return '';
    }
    hide(duration = 0, type) {
        if (this.type !== type)
            return;
        if (this.hideOpacityTimer)
            clearTimeout(this.hideOpacityTimer);
        if (this.hideDisplayTimer)
            clearTimeout(this.hideDisplayTimer);
        this.hideOpacityTimer = setTimeout(() => {
            this.el.style.opacity = '0';
            this.hideDisplayTimer = setTimeout(() => { this.el.style.display = 'none'; }, 100);
        }, duration);
    }
}

class Modal {
    constructor() {
        this.options = {
            title: '',
            content: '',
            showCancel: true,
            cancelText: '取消',
            cancelColor: '#000000',
            confirmText: '确定',
            confirmColor: '#3CC51F'
        };
        this.style = {
            maskStyle: {
                position: 'fixed',
                'z-index': '1000',
                top: '0',
                right: '0',
                left: '0',
                bottom: '0',
                background: 'rgba(0,0,0,0.6)'
            },
            modalStyle: {
                'z-index': '4999',
                position: 'fixed',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                width: '80%',
                'max-width': '300px',
                'border-radius': '3px',
                'text-align': 'center',
                'line-height': '1.6',
                overflow: 'hidden',
                background: '#FFFFFF'
            },
            titleStyle: {
                padding: '20px 24px 9px',
                'font-size': '18px'
            },
            textStyle: {
                padding: '0 24px 12px',
                'min-height': '40px',
                'font-size': '15px',
                'line-height': '1.3',
                color: '#808080'
            },
            footStyle: {
                position: 'relative',
                'line-height': '48px',
                'font-size': '18px',
                display: 'flex'
            },
            btnStyle: {
                position: 'relative',
                '-webkit-box-flex': '1',
                '-webkit-flex': '1',
                flex: '1'
            }
        };
    }
    create(options = {}) {
        return new Promise((resolve) => {
            // style
            const { maskStyle, modalStyle, titleStyle, textStyle, footStyle, btnStyle } = this.style;
            // configuration
            const config = {
                ...this.options,
                ...options
            };
            // wrapper
            this.el = document.createElement('div');
            this.el.className = 'taro__modal';
            this.el.style.opacity = '0';
            this.el.style.transition = 'opacity 0.2s linear';
            // mask
            const mask = document.createElement('div');
            mask.className = 'taro-modal__mask';
            mask.setAttribute('style', inlineStyle(maskStyle));
            // modal
            const modal = document.createElement('div');
            modal.className = 'taro-modal__content';
            modal.setAttribute('style', inlineStyle(modalStyle));
            // title
            const titleCSS = config.title ? titleStyle : {
                ...titleStyle,
                display: 'none'
            };
            this.title = document.createElement('div');
            this.title.className = 'taro-modal__title';
            this.title.setAttribute('style', inlineStyle(titleCSS));
            this.title.textContent = config.title;
            // text
            const textCSS = config.title ? textStyle : {
                ...textStyle,
                padding: '40px 20px 26px',
                color: '#353535'
            };
            this.text = document.createElement('div');
            this.text.className = 'taro-modal__text';
            this.text.setAttribute('style', inlineStyle(textCSS));
            this.text.textContent = config.content;
            // foot
            const foot = document.createElement('div');
            foot.className = 'taro-modal__foot';
            foot.setAttribute('style', inlineStyle(footStyle));
            // cancel button
            const cancelCSS = {
                ...btnStyle,
                color: config.cancelColor,
                display: config.showCancel ? 'block' : 'none'
            };
            this.cancel = document.createElement('div');
            this.cancel.className = 'taro-model__btn taro-model__cancel';
            this.cancel.setAttribute('style', inlineStyle(cancelCSS));
            this.cancel.textContent = config.cancelText;
            this.cancel.onclick = () => {
                this.hide();
                resolve('cancel');
            };
            // confirm button
            this.confirm = document.createElement('div');
            this.confirm.className = 'taro-model__btn taro-model__confirm';
            this.confirm.setAttribute('style', inlineStyle(btnStyle));
            this.confirm.style.color = config.confirmColor;
            this.confirm.textContent = config.confirmText;
            this.confirm.onclick = () => {
                this.hide();
                resolve('confirm');
            };
            // result
            foot.appendChild(this.cancel);
            foot.appendChild(this.confirm);
            modal.appendChild(this.title);
            modal.appendChild(this.text);
            modal.appendChild(foot);
            this.el.appendChild(mask);
            this.el.appendChild(modal);
            // show immediately
            document.body.appendChild(this.el);
            setTimeout(() => { this.el.style.opacity = '1'; }, 0);
        });
    }
    show(options = {}) {
        return new Promise((resolve) => {
            const config = {
                ...this.options,
                ...options
            };
            if (this.hideOpacityTimer)
                clearTimeout(this.hideOpacityTimer);
            if (this.hideDisplayTimer)
                clearTimeout(this.hideDisplayTimer);
            // title & text
            const { textStyle } = this.style;
            if (config.title) {
                this.title.textContent = config.title;
                // none => block
                this.title.style.display = 'block';
                this.text.setAttribute('style', inlineStyle(textStyle));
            }
            else {
                // block => none
                this.title.style.display = 'none';
                const textCSS = {
                    ...textStyle,
                    padding: '40px 20px 26px',
                    color: '#353535'
                };
                this.text.setAttribute('style', inlineStyle(textCSS));
            }
            this.text.textContent = config.content || '';
            // showCancel
            this.cancel.style.display = config.showCancel ? 'block' : 'none';
            // cancelText
            this.cancel.textContent = config.cancelText || '';
            // cancelColor
            this.cancel.style.color = config.cancelColor || '';
            // confirmText
            this.confirm.textContent = config.confirmText || '';
            // confirmColor
            this.confirm.style.color = config.confirmColor || '';
            // cbs
            this.cancel.onclick = () => {
                this.hide();
                resolve('cancel');
            };
            this.confirm.onclick = () => {
                this.hide();
                resolve('confirm');
            };
            // show
            this.el.style.display = 'block';
            setTimeout(() => { this.el.style.opacity = '1'; }, 0);
        });
    }
    hide() {
        if (this.hideOpacityTimer)
            clearTimeout(this.hideOpacityTimer);
        if (this.hideDisplayTimer)
            clearTimeout(this.hideDisplayTimer);
        this.hideOpacityTimer = setTimeout(() => {
            this.el.style.opacity = '0';
            this.hideDisplayTimer = setTimeout(() => { this.el.style.display = 'none'; }, 200);
        }, 0);
    }
}

const noop = function () { };
class ActionSheet {
    constructor() {
        this.options = {
            itemList: [],
            itemColor: '#000000',
            success: noop,
            fail: noop,
            complete: noop
        };
        this.style = {
            maskStyle: {
                position: 'fixed',
                'z-index': '1000',
                top: '0',
                right: '0',
                left: '0',
                bottom: '0',
                background: 'rgba(0,0,0,0.6)'
            },
            actionSheetStyle: {
                'z-index': '4999',
                position: 'fixed',
                left: '0',
                bottom: '0',
                '-webkit-transform': 'translate(0, 100%)',
                transform: 'translate(0, 100%)',
                width: '100%',
                'line-height': '1.6',
                background: '#EFEFF4',
                '-webkit-transition': '-webkit-transform .3s',
                transition: 'transform .3s'
            },
            menuStyle: {
                'background-color': '#FCFCFD'
            },
            cellStyle: {
                position: 'relative',
                padding: '10px 0',
                'text-align': 'center',
                'font-size': '18px'
            },
            cancelStyle: {
                'margin-top': '6px',
                padding: '10px 0',
                'text-align': 'center',
                'font-size': '18px',
                color: '#000000',
                'background-color': '#FCFCFD'
            }
        };
        this.lastConfig = {};
    }
    create(options = {}) {
        return new Promise((resolve) => {
            // style
            const { maskStyle, actionSheetStyle, menuStyle, cellStyle, cancelStyle } = this.style;
            // configuration
            const config = {
                ...this.options,
                ...options
            };
            this.lastConfig = config;
            // wrapper
            this.el = document.createElement('div');
            this.el.className = 'taro__actionSheet';
            this.el.style.opacity = '0';
            this.el.style.transition = 'opacity 0.2s linear';
            // mask
            const mask = document.createElement('div');
            mask.setAttribute('style', inlineStyle(maskStyle));
            // actionSheet
            this.actionSheet = document.createElement('div');
            this.actionSheet.setAttribute('style', inlineStyle(actionSheetStyle));
            // menu
            this.menu = document.createElement('div');
            this.menu.setAttribute('style', inlineStyle({
                ...menuStyle,
                color: config.itemColor
            }));
            // cells
            this.cells = config.itemList.map((item, index) => {
                const cell = document.createElement('div');
                cell.className = 'taro-actionsheet__cell';
                cell.setAttribute('style', inlineStyle(cellStyle));
                cell.textContent = item;
                cell.dataset.tapIndex = `${index}`;
                cell.onclick = e => {
                    this.hide();
                    const target = e.currentTarget;
                    const index = Number(target === null || target === void 0 ? void 0 : target.dataset.tapIndex) || 0;
                    resolve(index);
                };
                return cell;
            });
            // cancel
            this.cancel = document.createElement('div');
            this.cancel.setAttribute('style', inlineStyle(cancelStyle));
            this.cancel.textContent = '取消';
            // result
            this.cells.forEach(item => this.menu.appendChild(item));
            this.actionSheet.appendChild(this.menu);
            this.actionSheet.appendChild(this.cancel);
            this.el.appendChild(mask);
            this.el.appendChild(this.actionSheet);
            // callbacks
            const cb = () => {
                this.hide();
                resolve('cancel');
            };
            mask.onclick = cb;
            this.cancel.onclick = cb;
            // show immediately
            document.body.appendChild(this.el);
            setTimeout(() => {
                this.el.style.opacity = '1';
                setTransform(this.actionSheet, 'translate(0, 0)');
            }, 0);
        });
    }
    show(options = {}) {
        return new Promise((resolve) => {
            const config = {
                ...this.options,
                ...options
            };
            this.lastConfig = config;
            if (this.hideOpacityTimer)
                clearTimeout(this.hideOpacityTimer);
            if (this.hideDisplayTimer)
                clearTimeout(this.hideDisplayTimer);
            // itemColor
            if (config.itemColor)
                this.menu.style.color = config.itemColor;
            // cells
            const { cellStyle } = this.style;
            config.itemList.forEach((item, index) => {
                let cell;
                if (this.cells[index]) {
                    // assign new content
                    cell = this.cells[index];
                }
                else {
                    // create new cell
                    cell = document.createElement('div');
                    cell.className = 'taro-actionsheet__cell';
                    cell.setAttribute('style', inlineStyle(cellStyle));
                    cell.dataset.tapIndex = `${index}`;
                    this.cells.push(cell);
                    this.menu.appendChild(cell);
                }
                cell.textContent = item;
                cell.onclick = e => {
                    this.hide();
                    const target = e.currentTarget;
                    const index = Number(target === null || target === void 0 ? void 0 : target.dataset.tapIndex) || 0;
                    resolve(index);
                };
            });
            const cellsLen = this.cells.length;
            const itemListLen = config.itemList.length;
            if (cellsLen > itemListLen) {
                for (let i = itemListLen; i < cellsLen; i++) {
                    this.menu.removeChild(this.cells[i]);
                }
                this.cells.splice(itemListLen);
            }
            // show
            this.el.style.display = 'block';
            setTimeout(() => {
                this.el.style.opacity = '1';
                setTransform(this.actionSheet, 'translate(0, 0)');
            }, 0);
        });
    }
    hide() {
        if (this.hideOpacityTimer)
            clearTimeout(this.hideOpacityTimer);
        if (this.hideDisplayTimer)
            clearTimeout(this.hideDisplayTimer);
        this.hideOpacityTimer = setTimeout(() => {
            this.el.style.opacity = '0';
            setTransform(this.actionSheet, 'translate(0, 100%)');
            this.hideDisplayTimer = setTimeout(() => { this.el.style.display = 'none'; }, 200);
        }, 0);
    }
}

// 交互
let status = 'default';
// inject necessary style
function init(doc) {
    if (status === 'ready')
        return;
    const taroStyle = doc.createElement('style');
    taroStyle.textContent = '@font-face{font-weight:normal;font-style:normal;font-family:"taro";src:url("data:application/x-font-ttf;charset=utf-8;base64, AAEAAAALAIAAAwAwR1NVQrD+s+0AAAE4AAAAQk9TLzJWs0t/AAABfAAAAFZjbWFwqVgGvgAAAeAAAAGGZ2x5Zph7qG0AAANwAAAAdGhlYWQRFoGhAAAA4AAAADZoaGVhCCsD7AAAALwAAAAkaG10eAg0AAAAAAHUAAAADGxvY2EADAA6AAADaAAAAAhtYXhwAQ4AJAAAARgAAAAgbmFtZYrphEEAAAPkAAACVXBvc3S3shtSAAAGPAAAADUAAQAAA+gAAABaA+gAAAAAA+gAAQAAAAAAAAAAAAAAAAAAAAMAAQAAAAEAAADih+FfDzz1AAsD6AAAAADXB57LAAAAANcHnssAAP/sA+gDOgAAAAgAAgAAAAAAAAABAAAAAwAYAAEAAAAAAAIAAAAKAAoAAAD/AAAAAAAAAAEAAAAKAB4ALAABREZMVAAIAAQAAAAAAAAAAQAAAAFsaWdhAAgAAAABAAAAAQAEAAQAAAABAAgAAQAGAAAAAQAAAAAAAQK8AZAABQAIAnoCvAAAAIwCegK8AAAB4AAxAQIAAAIABQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUGZFZABAAHjqCAPoAAAAWgPoABQAAAABAAAAAAAAA+gAAABkAAAD6AAAAAAABQAAAAMAAAAsAAAABAAAAV4AAQAAAAAAWAADAAEAAAAsAAMACgAAAV4ABAAsAAAABgAEAAEAAgB46gj//wAAAHjqCP//AAAAAAABAAYABgAAAAEAAgAAAQYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAKAAAAAAAAAACAAAAeAAAAHgAAAABAADqCAAA6ggAAAACAAAAAAAAAAwAOgABAAD/7AAyABQAAgAANzMVFB4UKAAAAAABAAAAAAO7AzoAFwAAEy4BPwE+AR8BFjY3ATYWFycWFAcBBiInPQoGBwUHGgzLDCELAh0LHwsNCgr9uQoeCgGzCyEOCw0HCZMJAQoBvgkCCg0LHQv9sQsKAAAAAAAAEgDeAAEAAAAAAAAAHQAAAAEAAAAAAAEABAAdAAEAAAAAAAIABwAhAAEAAAAAAAMABAAoAAEAAAAAAAQABAAsAAEAAAAAAAUACwAwAAEAAAAAAAYABAA7AAEAAAAAAAoAKwA/AAEAAAAAAAsAEwBqAAMAAQQJAAAAOgB9AAMAAQQJAAEACAC3AAMAAQQJAAIADgC/AAMAAQQJAAMACADNAAMAAQQJAAQACADVAAMAAQQJAAUAFgDdAAMAAQQJAAYACADzAAMAAQQJAAoAVgD7AAMAAQQJAAsAJgFRCiAgQ3JlYXRlZCBieSBmb250LWNhcnJpZXIKICB3ZXVpUmVndWxhcndldWl3ZXVpVmVyc2lvbiAxLjB3ZXVpR2VuZXJhdGVkIGJ5IHN2ZzJ0dGYgZnJvbSBGb250ZWxsbyBwcm9qZWN0Lmh0dHA6Ly9mb250ZWxsby5jb20ACgAgACAAQwByAGUAYQB0AGUAZAAgAGIAeQAgAGYAbwBuAHQALQBjAGEAcgByAGkAZQByAAoAIAAgAHcAZQB1AGkAUgBlAGcAdQBsAGEAcgB3AGUAdQBpAHcAZQB1AGkAVgBlAHIAcwBpAG8AbgAgADEALgAwAHcAZQB1AGkARwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABzAHYAZwAyAHQAdABmACAAZgByAG8AbQAgAEYAbwBuAHQAZQBsAGwAbwAgAHAAcgBvAGoAZQBjAHQALgBoAHQAdABwADoALwAvAGYAbwBuAHQAZQBsAGwAbwAuAGMAbwBtAAAAAAIAAAAAAAAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwECAQMBBAABeAd1bmlFQTA4AAAAAAA=") format("truetype");}@-webkit-keyframes taroLoading{0%{-webkit-transform:rotate3d(0, 0, 1, 0deg);}100%{-webkit-transform:rotate3d(0, 0, 1, 360deg);transform:rotate3d(0, 0, 1, 360deg);}}@keyframes taroLoading{0%{-webkit-transform:rotate3d(0, 0, 1, 0deg);}100%{-webkit-transform:rotate3d(0, 0, 1, 360deg);transform:rotate3d(0, 0, 1, 360deg);}}.taro-modal__foot:after {content: "";position: absolute;left: 0;top: 0;right: 0;height: 1px;border-top: 1px solid #D5D5D6;color: #D5D5D6;-webkit-transform-origin: 0 0;transform-origin: 0 0;-webkit-transform: scaleY(0.5);transform: scaleY(0.5);} .taro-model__btn:active {background-color: #EEEEEE}.taro-model__btn:not(:first-child):after {content: "";position: absolute;left: 0;top: 0;width: 1px;bottom: 0;border-left: 1px solid #D5D5D6;color: #D5D5D6;-webkit-transform-origin: 0 0;transform-origin: 0 0;-webkit-transform: scaleX(0.5);transform: scaleX(0.5);}.taro-actionsheet__cell:not(:first-child):after {content: "";position: absolute;left: 0;top: 0;right: 0;height: 1px;border-top: 1px solid #e5e5e5;color: #e5e5e5;-webkit-transform-origin: 0 0;transform-origin: 0 0;-webkit-transform: scaleY(0.5);transform: scaleY(0.5);}';
    doc.querySelector('head').appendChild(taroStyle);
    status = 'ready';
}
const toast = new Toast();
const modal = new Modal();
const actionSheet = new ActionSheet();
const showToast = (options = { title: '' }) => {
    init(document);
    options = Object.assign({
        title: '',
        icon: 'success',
        image: '',
        duration: 1500,
        mask: false
    }, options);
    const { success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'showToast', success, fail, complete });
    if (typeof options.title !== 'string') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'title',
                correct: 'String',
                wrong: options.title
            })
        });
    }
    if (typeof options.duration !== 'number') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'duration',
                correct: 'Number',
                wrong: options.duration
            })
        });
    }
    if (options.image && typeof options.image !== 'string')
        options.image = '';
    options.mask = !!options.mask;
    let errMsg = '';
    if (!toast.el) {
        errMsg = toast.create(options, 'toast');
    }
    else {
        errMsg = toast.show(options, 'toast');
    }
    return handle.success({ errMsg });
};
const hideToast = ({ success, fail, complete } = {}) => {
    const handle = new MethodHandler({ name: 'hideToast', success, fail, complete });
    if (!toast.el)
        return handle.success();
    toast.hide(0, 'toast');
    return handle.success();
};
const showLoading = (options = { title: '' }) => {
    init(document);
    options = Object.assign({
        title: '',
        mask: false
    }, options);
    const { success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'showLoading', success, fail, complete });
    const config = {
        icon: 'loading',
        image: '',
        duration: -1
    };
    options = Object.assign({}, options, config);
    if (typeof options.title !== 'string') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'title',
                correct: 'String',
                wrong: options.title
            })
        });
    }
    options.mask = !!options.mask;
    let errMsg = '';
    if (!toast.el) {
        errMsg = toast.create(options, 'loading');
    }
    else {
        errMsg = toast.show(options, 'loading');
    }
    return handle.success({ errMsg });
};
const hideLoading = ({ success, fail, complete } = {}) => {
    const handle = new MethodHandler({ name: 'hideLoading', success, fail, complete });
    if (!toast.el)
        return handle.success();
    toast.hide(0, 'loading');
    return handle.success();
};
const showModal = async (options = {}) => {
    init(document);
    options = Object.assign({
        title: '',
        content: '',
        showCancel: true,
        cancelText: '取消',
        cancelColor: '#000000',
        confirmText: '确定',
        confirmColor: '#3CC51F'
    }, options);
    const { success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'showModal', success, fail, complete });
    if (typeof options.title !== 'string') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'title',
                correct: 'String',
                wrong: options.title
            })
        });
    }
    if (typeof options.content !== 'string') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'content',
                correct: 'String',
                wrong: options.content
            })
        });
    }
    if (typeof options.cancelText !== 'string') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'cancelText',
                correct: 'String',
                wrong: options.cancelText
            })
        });
    }
    if (options.cancelText.replace(/[\u0391-\uFFE5]/g, 'aa').length > 8) {
        return handle.fail({
            errMsg: 'cancelText length should not larger then 4 Chinese characters'
        });
    }
    if (typeof options.confirmText !== 'string') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'confirmText',
                correct: 'String',
                wrong: options.confirmText
            })
        });
    }
    if (options.confirmText.replace(/[\u0391-\uFFE5]/g, 'aa').length > 8) {
        return handle.fail({
            errMsg: 'confirmText length should not larger then 4 Chinese characters'
        });
    }
    if (typeof options.cancelColor !== 'string') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'cancelColor',
                correct: 'String',
                wrong: options.cancelColor
            })
        });
    }
    if (typeof options.confirmColor !== 'string') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'confirmColor',
                correct: 'String',
                wrong: options.confirmColor
            })
        });
    }
    options.showCancel = !!options.showCancel;
    let result = '';
    if (!modal.el) {
        result = await modal.create(options);
    }
    else {
        result = await modal.show(options);
    }
    const res = { cancel: !1, confirm: !1 };
    res[result] = !0;
    return handle.success(res);
};
function hideModal() {
    if (!modal.el)
        return;
    modal.hide();
}
const showActionSheet = async (options = { itemList: [] }) => {
    init(document);
    options = Object.assign({
        itemColor: '#000000',
        itemList: []
    }, options);
    const { success, fail, complete } = options;
    const handle = new MethodHandler({ name: 'showActionSheet', success, fail, complete });
    // list item String
    if (!Array.isArray(options.itemList)) {
        return handle.fail({
            errMsg: getParameterError({
                para: 'itemList',
                correct: 'Array',
                wrong: options.itemList
            })
        });
    }
    if (options.itemList.length < 1) {
        return handle.fail({ errMsg: 'parameter error: parameter.itemList should have at least 1 item' });
    }
    if (options.itemList.length > 6) {
        return handle.fail({ errMsg: 'parameter error: parameter.itemList should not be large than 6' });
    }
    for (let i = 0; i < options.itemList.length; i++) {
        if (typeof options.itemList[i] !== 'string') {
            return handle.fail({
                errMsg: getParameterError({
                    para: `itemList[${i}]`,
                    correct: 'String',
                    wrong: options.itemList[i]
                })
            });
        }
    }
    if (typeof options.itemColor !== 'string') {
        return handle.fail({
            errMsg: getParameterError({
                para: 'itemColor',
                correct: 'String',
                wrong: options.itemColor
            })
        });
    }
    let result = '';
    if (!actionSheet.el) {
        result = await actionSheet.create(options);
    }
    else {
        result = await actionSheet.show(options);
    }
    if (typeof result === 'string') {
        return handle.fail(({ errMsg: result }));
    }
    else {
        return handle.success(({ tapIndex: result }));
    }
};
Taro__default["default"].eventCenter.on('__taroRouterChange', () => {
    hideToast();
    hideLoading();
    hideModal();
});
const enableAlertBeforeUnload = temporarilyNotSupport('enableAlertBeforeUnload');
const disableAlertBeforeUnload = temporarilyNotSupport('disableAlertBeforeUnload');

// Worker
const createWorker = temporarilyNotSupport('createWorker');

class NodesRef {
    constructor(selector, querySelectorQuery, single) {
        this._component = querySelectorQuery._component;
        this._selector = selector;
        this._selectorQuery = querySelectorQuery;
        this._single = single;
    }
    context(cb) {
        const { _selector, _component, _single, _selectorQuery } = this;
        _selectorQuery._push(_selector, _component, _single, { context: !0 }, cb);
        return _selectorQuery;
    }
    node(cb) {
        const { _selector, _component, _single, _selectorQuery } = this;
        _selectorQuery._push(_selector, _component, _single, { nodeCanvasType: !0, node: !0 }, cb);
        return _selectorQuery;
    }
    boundingClientRect(cb) {
        const { _selector, _component, _single, _selectorQuery } = this;
        _selectorQuery._push(_selector, _component, _single, { id: !0, dataset: !0, rect: !0, size: !0 }, cb);
        return _selectorQuery;
    }
    scrollOffset(cb) {
        const { _selector, _component, _single, _selectorQuery } = this;
        _selectorQuery._push(_selector, _component, _single, { id: !0, dataset: !0, scrollOffset: !0 }, cb);
        return _selectorQuery;
    }
    fields(fields, cb) {
        const { _selector, _component, _single, _selectorQuery } = this;
        const { id, dataset, rect, size, scrollOffset, properties = [], computedStyle = [] } = fields;
        _selectorQuery._push(_selector, _component, _single, {
            id,
            dataset,
            rect,
            size,
            scrollOffset,
            properties,
            computedStyle
        }, cb);
        return _selectorQuery;
    }
}

function filter(fields, dom, selector) {
    if (!dom)
        return null;
    const isViewport = selector === '.taro_page';
    const { id, dataset, rect, size, scrollOffset, properties = [], computedStyle = [], nodeCanvasType, node, context } = fields;
    const res = {};
    if (nodeCanvasType && node) {
        const tagName = dom.tagName;
        res.node = {
            id: dom.id,
            $taroElement: dom
        };
        if (/^taro-canvas-core/i.test(tagName)) {
            const type = dom.type || '';
            res.nodeCanvasType = type;
            const canvas = dom.getElementsByTagName('canvas')[0];
            if (/^(2d|webgl)/i.test(type) && canvas) {
                res.node = canvas;
            }
            else {
                res.node = null;
            }
        }
        else {
            // TODO https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html
            // if (/^taro-scroll-view-core/i.test(tagName))
            res.nodeCanvasType = '';
            res.node = dom;
        }
        return res;
    }
    if (context) {
        const tagName = dom.tagName;
        if (/^taro-video-core/i.test(tagName)) {
            // TODO HTMLVideoElement to VideoContext
            return { context: dom };
        }
        else if (/^taro-canvas-core/i.test(tagName)) {
            const type = dom.type || '2d';
            const canvas = dom === null || dom === void 0 ? void 0 : dom.querySelector('canvas');
            const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext(type);
            return { context: new CanvasContext(canvas, ctx) };
        }
        else if (/^taro-live-player-core/i.test(tagName)) {
            console.error('暂时不支持通过 NodesRef.context 获取 LivePlayerContext');
        }
        else if (/^taro-editor-core/i.test(tagName)) {
            console.error('暂时不支持通过 NodesRef.context 获取 EditorContext');
        }
        else if (/^taro-map-core/i.test(tagName)) {
            console.error('暂时不支持通过 NodesRef.context 获取 MapContext');
        }
        return;
    }
    if (id)
        res.id = dom.id;
    if (dataset)
        res.dataset = Object.assign({}, dom.dataset);
    if (rect || size) {
        const { left, right, top, bottom, width, height } = dom.getBoundingClientRect();
        if (rect) {
            if (!isViewport) {
                res.left = left;
                res.right = right;
                res.top = top;
                res.bottom = bottom;
            }
            else {
                res.left = 0;
                res.right = 0;
                res.top = 0;
                res.bottom = 0;
            }
        }
        if (size) {
            if (!isViewport) {
                res.width = width;
                res.height = height;
            }
            else {
                res.width = dom.clientWidth;
                res.height = dom.clientHeight;
            }
        }
    }
    if (scrollOffset) {
        res.scrollLeft = dom.scrollLeft;
        res.scrollTop = dom.scrollTop;
    }
    if (properties.length) {
        properties.forEach(prop => {
            const attr = dom.getAttribute(prop);
            if (attr)
                res[prop] = attr;
        });
    }
    if (computedStyle.length) {
        const styles = window.getComputedStyle(dom);
        computedStyle.forEach(key => {
            const value = styles.getPropertyValue(key) || styles[key];
            if (value)
                res[key] = value;
        });
    }
    return res;
}
/**
 * WXML节点信息API
 * @return {Object} SelectorQuery 对象实例
 */
function queryBat(queue, cb) {
    const result = [];
    queue.forEach(item => {
        var _a;
        const { selector, single, fields, component } = item;
        // selector 的容器节点
        /* eslint-disable */
        const container = (component !== null ?
            (findDOM(component) || document) :
            document);
        /* eslint-enable */
        // 特殊处理 ---- 选自己
        let selectSelf = false;
        if (container !== document) {
            const $nodeList = (_a = container.parentNode) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector);
            if ($nodeList) {
                for (let i = 0, len = $nodeList.length; i < len; ++i) {
                    if (container === $nodeList[i]) {
                        selectSelf = true;
                        break;
                    }
                }
            }
        }
        if (single) {
            const el = selectSelf === true ? container : container.querySelector(selector);
            result.push(filter(fields, el, selector));
        }
        else {
            const $children = container.querySelectorAll(selector);
            const children = [];
            selectSelf === true && children.push(container);
            for (let i = 0, len = $children.length; i < len; ++i) {
                children.push($children[i]);
            }
            result.push(children.map(dom => filter(fields, dom)));
        }
    });
    cb(result);
}
class SelectorQuery {
    constructor() {
        this._defaultWebviewId = null;
        this._webviewId = null;
        this._queue = [];
        this._queueCb = [];
        this._component;
    }
    in(component) {
        this._component = component;
        return this;
    }
    select(selector) {
        // 小程序里跨自定义组件的后代选择器 '>>>' 在 h5 替换为普通后代选择器 '>'
        if (typeof selector === 'string')
            selector = selector.replace('>>>', '>');
        return new NodesRef(selector, this, true);
    }
    selectAll(selector) {
        // 小程序里跨自定义组件的后代选择器 '>>>' 在 h5 替换为普通后代选择器 '>'
        if (typeof selector === 'string')
            selector = selector.replace('>>>', '>');
        return new NodesRef(selector, this, false);
    }
    selectViewport() {
        return new NodesRef('.taro_page', this, true);
    }
    exec(cb) {
        queryBat(this._queue, res => {
            const _queueCb = this._queueCb;
            res.forEach((item, index) => {
                const cb = _queueCb[index];
                typeof cb === 'function' && cb.call(this, item);
            });
            typeof cb === 'function' && cb.call(this, res);
        });
        return this;
    }
    _push(selector, component, single, fields, callback = null) {
        this._queue.push({
            component,
            selector,
            single,
            fields
        });
        this._queueCb.push(callback);
    }
}

const createSelectorQuery = () => {
    return new SelectorQuery();
};
const createIntersectionObserver = temporarilyNotSupport('createIntersectionObserver');

// AliPay
const getOpenUserInfo = temporarilyNotSupport('getOpenUserInfo');

const setPageInfo = temporarilyNotSupport('setPageInfo');
// 百度小程序 AI 相关
const ocrIdCard = temporarilyNotSupport('ocrIdCard');
const ocrBankCard = temporarilyNotSupport('ocrBankCard');
const ocrDrivingLicense = temporarilyNotSupport('ocrDrivingLicense');
const ocrVehicleLicense = temporarilyNotSupport('ocrVehicleLicense');
const textReview = temporarilyNotSupport('textReview');
const textToAudio = temporarilyNotSupport('textToAudio');
const imageAudit = temporarilyNotSupport('imageAudit');
const advancedGeneralIdentify = temporarilyNotSupport('advancedGeneralIdentify');
const objectDetectIdentify = temporarilyNotSupport('objectDetectIdentify');
const carClassify = temporarilyNotSupport('carClassify');
const dishClassify = temporarilyNotSupport('dishClassify');
const logoClassify = temporarilyNotSupport('logoClassify');
const animalClassify = temporarilyNotSupport('animalClassify');
const plantClassify = temporarilyNotSupport('plantClassify');
// 用户信息
const getSwanId = temporarilyNotSupport('getSwanId');
// 百度收银台支付
const requestPolymerPayment = temporarilyNotSupport('requestPolymerPayment');
// 打开小程序
const navigateToSmartGameProgram = temporarilyNotSupport('navigateToSmartGameProgram');
const navigateToSmartProgram = temporarilyNotSupport('navigateToSmartProgram');
const navigateBackSmartProgram = temporarilyNotSupport('navigateBackSmartProgram');
const preloadSubPackage = temporarilyNotSupport('preloadSubPackage');

const { Behavior, getEnv, ENV_TYPE, Link, interceptors, getInitPxTransform, Current, options, eventCenter, Events, preload } = Taro__default["default"];
const taro = {
    // @ts-ignore
    Behavior,
    getEnv,
    ENV_TYPE,
    Link,
    interceptors,
    Current,
    getCurrentInstance,
    options,
    nextTick,
    eventCenter,
    Events,
    preload,
    history: router.history,
    createRouter: router.createRouter,
    navigateBack: router.navigateBack,
    navigateTo: router.navigateTo,
    reLaunch: router.reLaunch,
    redirectTo: router.redirectTo,
    getCurrentPages: router.getCurrentPages,
    switchTab: router.switchTab
};
const initPxTransform = getInitPxTransform(taro);
const requirePlugin = permanentlyNotSupport('requirePlugin');
const pxTransform = function (size) {
    // @ts-ignore
    const { designWidth } = taro.config;
    return Math.ceil((((parseInt(size, 10) / 40) * 640) / designWidth) * 10000) / 10000 + 'rem';
};
const canIUseWebp = function () {
    const canvas = document.createElement('canvas');
    return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
};
taro.requirePlugin = requirePlugin;
taro.getApp = getApp;
taro.pxTransform = pxTransform;
taro.initPxTransform = initPxTransform;
// @ts-ignore
taro.canIUseWebp = canIUseWebp;

Object.defineProperty(exports, 'createRouter', {
    enumerable: true,
    get: function () { return router.createRouter; }
});
Object.defineProperty(exports, 'getCurrentPages', {
    enumerable: true,
    get: function () { return router.getCurrentPages; }
});
Object.defineProperty(exports, 'history', {
    enumerable: true,
    get: function () { return router.history; }
});
Object.defineProperty(exports, 'navigateBack', {
    enumerable: true,
    get: function () { return router.navigateBack; }
});
Object.defineProperty(exports, 'navigateTo', {
    enumerable: true,
    get: function () { return router.navigateTo; }
});
Object.defineProperty(exports, 'reLaunch', {
    enumerable: true,
    get: function () { return router.reLaunch; }
});
Object.defineProperty(exports, 'redirectTo', {
    enumerable: true,
    get: function () { return router.redirectTo; }
});
Object.defineProperty(exports, 'switchTab', {
    enumerable: true,
    get: function () { return router.switchTab; }
});
exports.Behavior = Behavior;
exports.Current = Current;
exports.ENV_TYPE = ENV_TYPE;
exports.Events = Events;
exports.Link = Link;
exports.addCard = addCard;
exports.addFileToFavorites = addFileToFavorites;
exports.addInterceptor = addInterceptor;
exports.addPhoneCalendar = addPhoneCalendar;
exports.addPhoneContact = addPhoneContact;
exports.addPhoneRepeatCalendar = addPhoneRepeatCalendar;
exports.addVideoToFavorites = addVideoToFavorites;
exports.advancedGeneralIdentify = advancedGeneralIdentify;
exports.animalClassify = animalClassify;
exports.arrayBufferToBase64 = arrayBufferToBase64;
exports.authPrivateMessage = authPrivateMessage;
exports.authorize = authorize;
exports.authorizeForMiniProgram = authorizeForMiniProgram;
exports.base64ToArrayBuffer = base64ToArrayBuffer;
exports.canIUse = canIUse;
exports.canIUseWebp = canIUseWebp;
exports.canvasGetImageData = canvasGetImageData;
exports.canvasPutImageData = canvasPutImageData;
exports.canvasToTempFilePath = canvasToTempFilePath;
exports.carClassify = carClassify;
exports.checkIsOpenAccessibility = checkIsOpenAccessibility;
exports.checkIsSoterEnrolledInDevice = checkIsSoterEnrolledInDevice;
exports.checkIsSupportFacialRecognition = checkIsSupportFacialRecognition;
exports.checkIsSupportSoterAuthentication = checkIsSupportSoterAuthentication;
exports.checkSession = checkSession;
exports.chooseAddress = chooseAddress;
exports.chooseContact = chooseContact;
exports.chooseImage = chooseImage;
exports.chooseInvoice = chooseInvoice;
exports.chooseInvoiceTitle = chooseInvoiceTitle;
exports.chooseLicensePlate = chooseLicensePlate;
exports.chooseLocation = chooseLocation;
exports.chooseMedia = chooseMedia;
exports.chooseMessageFile = chooseMessageFile;
exports.choosePoi = choosePoi;
exports.chooseVideo = chooseVideo;
exports.clearStorage = clearStorage;
exports.clearStorageSync = clearStorageSync;
exports.closeBLEConnection = closeBLEConnection;
exports.closeBluetoothAdapter = closeBluetoothAdapter;
exports.closeSocket = closeSocket;
exports.cloud = cloud;
exports.compressImage = compressImage;
exports.compressVideo = compressVideo;
exports.connectSocket = connectSocket;
exports.connectWifi = connectWifi;
exports.createAnimation = createAnimation;
exports.createAudioContext = createAudioContext;
exports.createBLEConnection = createBLEConnection;
exports.createBLEPeripheralServer = createBLEPeripheralServer;
exports.createBufferURL = createBufferURL;
exports.createCameraContext = createCameraContext;
exports.createCanvasContext = createCanvasContext;
exports.createInnerAudioContext = createInnerAudioContext;
exports.createIntersectionObserver = createIntersectionObserver;
exports.createInterstitialAd = createInterstitialAd;
exports.createLivePlayerContext = createLivePlayerContext;
exports.createLivePusherContext = createLivePusherContext;
exports.createMapContext = createMapContext;
exports.createMediaAudioPlayer = createMediaAudioPlayer;
exports.createMediaContainer = createMediaContainer;
exports.createMediaRecorder = createMediaRecorder;
exports.createOffscreenCanvas = createOffscreenCanvas;
exports.createRewardedVideoAd = createRewardedVideoAd;
exports.createSelectorQuery = createSelectorQuery;
exports.createTCPSocket = createTCPSocket;
exports.createUDPSocket = createUDPSocket;
exports.createVKSession = createVKSession;
exports.createVideoContext = createVideoContext;
exports.createVideoDecoder = createVideoDecoder;
exports.createWebAudioContext = createWebAudioContext;
exports.createWorker = createWorker;
exports["default"] = taro;
exports.disableAlertBeforeUnload = disableAlertBeforeUnload;
exports.dishClassify = dishClassify;
exports.downloadFile = downloadFile;
exports.enableAlertBeforeUnload = enableAlertBeforeUnload;
exports.eventCenter = eventCenter;
exports.exitMiniProgram = exitMiniProgram;
exports.exitVoIPChat = exitVoIPChat;
exports.faceDetect = faceDetect;
exports.faceVerifyForPay = faceVerifyForPay;
exports.getAccountInfoSync = getAccountInfoSync;
exports.getApp = getApp;
exports.getAppAuthorizeSetting = getAppAuthorizeSetting;
exports.getAppBaseInfo = getAppBaseInfo;
exports.getAvailableAudioSources = getAvailableAudioSources;
exports.getBLEDeviceCharacteristics = getBLEDeviceCharacteristics;
exports.getBLEDeviceRSSI = getBLEDeviceRSSI;
exports.getBLEDeviceServices = getBLEDeviceServices;
exports.getBLEMTU = getBLEMTU;
exports.getBackgroundAudioManager = getBackgroundAudioManager;
exports.getBackgroundAudioPlayerState = getBackgroundAudioPlayerState;
exports.getBackgroundFetchData = getBackgroundFetchData;
exports.getBackgroundFetchToken = getBackgroundFetchToken;
exports.getBatteryInfo = getBatteryInfo;
exports.getBatteryInfoSync = getBatteryInfoSync;
exports.getBeacons = getBeacons;
exports.getBluetoothAdapterState = getBluetoothAdapterState;
exports.getBluetoothDevices = getBluetoothDevices;
exports.getChannelsLiveInfo = getChannelsLiveInfo;
exports.getChannelsLiveNoticeInfo = getChannelsLiveNoticeInfo;
exports.getClipboardData = getClipboardData;
exports.getConnectedBluetoothDevices = getConnectedBluetoothDevices;
exports.getConnectedWifi = getConnectedWifi;
exports.getCurrentInstance = getCurrentInstance;
exports.getDeviceInfo = getDeviceInfo;
exports.getEnterOptionsSync = getEnterOptionsSync;
exports.getEnv = getEnv;
exports.getExptInfoSync = getExptInfoSync;
exports.getExtConfig = getExtConfig;
exports.getExtConfigSync = getExtConfigSync;
exports.getFileInfo = getFileInfo;
exports.getFileSystemManager = getFileSystemManager;
exports.getGroupEnterInfo = getGroupEnterInfo;
exports.getHCEState = getHCEState;
exports.getImageInfo = getImageInfo;
exports.getLaunchOptionsSync = getLaunchOptionsSync;
exports.getLocalIPAddress = getLocalIPAddress;
exports.getLocation = getLocation;
exports.getLogManager = getLogManager;
exports.getMenuButtonBoundingClientRect = getMenuButtonBoundingClientRect;
exports.getNFCAdapter = getNFCAdapter;
exports.getNetworkType = getNetworkType;
exports.getOpenUserInfo = getOpenUserInfo;
exports.getPerformance = getPerformance;
exports.getRandomValues = getRandomValues;
exports.getRealtimeLogManager = getRealtimeLogManager;
exports.getRecorderManager = getRecorderManager;
exports.getSavedFileInfo = getSavedFileInfo;
exports.getSavedFileList = getSavedFileList;
exports.getScreenBrightness = getScreenBrightness;
exports.getSelectedTextRange = getSelectedTextRange;
exports.getSetting = getSetting;
exports.getShareInfo = getShareInfo;
exports.getStorage = getStorage;
exports.getStorageInfo = getStorageInfo;
exports.getStorageInfoSync = getStorageInfoSync;
exports.getStorageSync = getStorageSync;
exports.getSwanId = getSwanId;
exports.getSystemInfo = getSystemInfo;
exports.getSystemInfoAsync = getSystemInfoAsync;
exports.getSystemInfoSync = getSystemInfoSync;
exports.getSystemSetting = getSystemSetting;
exports.getUpdateManager = getUpdateManager;
exports.getUserCryptoManager = getUserCryptoManager;
exports.getUserInfo = getUserInfo;
exports.getUserProfile = getUserProfile;
exports.getVideoInfo = getVideoInfo;
exports.getWeRunData = getWeRunData;
exports.getWifiList = getWifiList;
exports.getWindowInfo = getWindowInfo;
exports.hideHomeButton = hideHomeButton;
exports.hideKeyboard = hideKeyboard;
exports.hideLoading = hideLoading;
exports.hideNavigationBarLoading = hideNavigationBarLoading;
exports.hideShareMenu = hideShareMenu;
exports.hideTabBar = hideTabBar;
exports.hideTabBarRedDot = hideTabBarRedDot;
exports.hideToast = hideToast;
exports.imageAudit = imageAudit;
exports.initFaceDetect = initFaceDetect;
exports.initPxTransform = initPxTransform;
exports.initTabBarApis = initTabBarApis;
exports.interceptors = interceptors;
exports.isBluetoothDevicePaired = isBluetoothDevicePaired;
exports.isVKSupport = isVKSupport;
exports.joinVoIPChat = joinVoIPChat;
exports.loadFontFace = loadFontFace;
exports.login = login;
exports.logoClassify = logoClassify;
exports.makeBluetoothPair = makeBluetoothPair;
exports.makePhoneCall = makePhoneCall;
exports.navigateBackMiniProgram = navigateBackMiniProgram;
exports.navigateBackSmartProgram = navigateBackSmartProgram;
exports.navigateToMiniProgram = navigateToMiniProgram;
exports.navigateToSmartGameProgram = navigateToSmartGameProgram;
exports.navigateToSmartProgram = navigateToSmartProgram;
exports.nextTick = nextTick;
exports.notifyBLECharacteristicValueChange = notifyBLECharacteristicValueChange;
exports.objectDetectIdentify = objectDetectIdentify;
exports.ocrBankCard = ocrBankCard;
exports.ocrDrivingLicense = ocrDrivingLicense;
exports.ocrIdCard = ocrIdCard;
exports.ocrVehicleLicense = ocrVehicleLicense;
exports.offAccelerometerChange = offAccelerometerChange;
exports.offAppHide = offAppHide;
exports.offAppShow = offAppShow;
exports.offAudioInterruptionBegin = offAudioInterruptionBegin;
exports.offAudioInterruptionEnd = offAudioInterruptionEnd;
exports.offBLECharacteristicValueChange = offBLECharacteristicValueChange;
exports.offBLEConnectionStateChange = offBLEConnectionStateChange;
exports.offBLEMTUChange = offBLEMTUChange;
exports.offBLEPeripheralConnectionStateChanged = offBLEPeripheralConnectionStateChanged;
exports.offBeaconServiceChange = offBeaconServiceChange;
exports.offBeaconUpdate = offBeaconUpdate;
exports.offBluetoothAdapterStateChange = offBluetoothAdapterStateChange;
exports.offBluetoothDeviceFound = offBluetoothDeviceFound;
exports.offCompassChange = offCompassChange;
exports.offCopyUrl = offCopyUrl;
exports.offDeviceMotionChange = offDeviceMotionChange;
exports.offError = offError;
exports.offGetWifiList = offGetWifiList;
exports.offGyroscopeChange = offGyroscopeChange;
exports.offHCEMessage = offHCEMessage;
exports.offKeyboardHeightChange = offKeyboardHeightChange;
exports.offLocalServiceDiscoveryStop = offLocalServiceDiscoveryStop;
exports.offLocalServiceFound = offLocalServiceFound;
exports.offLocalServiceLost = offLocalServiceLost;
exports.offLocalServiceResolveFail = offLocalServiceResolveFail;
exports.offLocationChange = offLocationChange;
exports.offLocationChangeError = offLocationChangeError;
exports.offMemoryWarning = offMemoryWarning;
exports.offNetworkStatusChange = offNetworkStatusChange;
exports.offNetworkWeakChange = offNetworkWeakChange;
exports.offPageNotFound = offPageNotFound;
exports.offThemeChange = offThemeChange;
exports.offUnhandledRejection = offUnhandledRejection;
exports.offUserCaptureScreen = offUserCaptureScreen;
exports.offVoIPChatInterrupted = offVoIPChatInterrupted;
exports.offVoIPChatMembersChanged = offVoIPChatMembersChanged;
exports.offVoIPChatStateChanged = offVoIPChatStateChanged;
exports.offVoIPVideoMembersChanged = offVoIPVideoMembersChanged;
exports.offWifiConnected = offWifiConnected;
exports.offWindowResize = offWindowResize;
exports.onAccelerometerChange = onAccelerometerChange;
exports.onAppHide = onAppHide;
exports.onAppShow = onAppShow;
exports.onAudioInterruptionBegin = onAudioInterruptionBegin;
exports.onAudioInterruptionEnd = onAudioInterruptionEnd;
exports.onBLECharacteristicValueChange = onBLECharacteristicValueChange;
exports.onBLEConnectionStateChange = onBLEConnectionStateChange;
exports.onBLEMTUChange = onBLEMTUChange;
exports.onBLEPeripheralConnectionStateChanged = onBLEPeripheralConnectionStateChanged;
exports.onBackgroundAudioPause = onBackgroundAudioPause;
exports.onBackgroundAudioPlay = onBackgroundAudioPlay;
exports.onBackgroundAudioStop = onBackgroundAudioStop;
exports.onBackgroundFetchData = onBackgroundFetchData;
exports.onBeaconServiceChange = onBeaconServiceChange;
exports.onBeaconUpdate = onBeaconUpdate;
exports.onBluetoothAdapterStateChange = onBluetoothAdapterStateChange;
exports.onBluetoothDeviceFound = onBluetoothDeviceFound;
exports.onCompassChange = onCompassChange;
exports.onCopyUrl = onCopyUrl;
exports.onDeviceMotionChange = onDeviceMotionChange;
exports.onError = onError;
exports.onGetWifiList = onGetWifiList;
exports.onGyroscopeChange = onGyroscopeChange;
exports.onHCEMessage = onHCEMessage;
exports.onKeyboardHeightChange = onKeyboardHeightChange;
exports.onLocalServiceDiscoveryStop = onLocalServiceDiscoveryStop;
exports.onLocalServiceFound = onLocalServiceFound;
exports.onLocalServiceLost = onLocalServiceLost;
exports.onLocalServiceResolveFail = onLocalServiceResolveFail;
exports.onLocationChange = onLocationChange;
exports.onLocationChangeError = onLocationChangeError;
exports.onMemoryWarning = onMemoryWarning;
exports.onNetworkStatusChange = onNetworkStatusChange;
exports.onNetworkWeakChange = onNetworkWeakChange;
exports.onPageNotFound = onPageNotFound;
exports.onSocketClose = onSocketClose;
exports.onSocketError = onSocketError;
exports.onSocketMessage = onSocketMessage;
exports.onSocketOpen = onSocketOpen;
exports.onThemeChange = onThemeChange;
exports.onUnhandledRejection = onUnhandledRejection;
exports.onUserCaptureScreen = onUserCaptureScreen;
exports.onVoIPChatInterrupted = onVoIPChatInterrupted;
exports.onVoIPChatMembersChanged = onVoIPChatMembersChanged;
exports.onVoIPChatSpeakersChanged = onVoIPChatSpeakersChanged;
exports.onVoIPChatStateChanged = onVoIPChatStateChanged;
exports.onVoIPVideoMembersChanged = onVoIPVideoMembersChanged;
exports.onWifiConnected = onWifiConnected;
exports.onWifiConnectedWithPartialInfo = onWifiConnectedWithPartialInfo;
exports.onWindowResize = onWindowResize;
exports.openAppAuthorizeSetting = openAppAuthorizeSetting;
exports.openBluetoothAdapter = openBluetoothAdapter;
exports.openCard = openCard;
exports.openChannelsActivity = openChannelsActivity;
exports.openChannelsEvent = openChannelsEvent;
exports.openChannelsLive = openChannelsLive;
exports.openCustomerServiceChat = openCustomerServiceChat;
exports.openDocument = openDocument;
exports.openEmbeddedMiniProgram = openEmbeddedMiniProgram;
exports.openLocation = openLocation;
exports.openSetting = openSetting;
exports.openSystemBluetoothSetting = openSystemBluetoothSetting;
exports.openVideoEditor = openVideoEditor;
exports.options = options;
exports.pageScrollTo = pageScrollTo;
exports.pauseBackgroundAudio = pauseBackgroundAudio;
exports.pauseVoice = pauseVoice;
exports.plantClassify = plantClassify;
exports.playBackgroundAudio = playBackgroundAudio;
exports.playVoice = playVoice;
exports.pluginLogin = pluginLogin;
exports.preload = preload;
exports.preloadSubPackage = preloadSubPackage;
exports.previewImage = previewImage;
exports.previewMedia = previewMedia;
exports.pxTransform = pxTransform;
exports.readBLECharacteristicValue = readBLECharacteristicValue;
exports.removeSavedFile = removeSavedFile;
exports.removeStorage = removeStorage;
exports.removeStorageSync = removeStorageSync;
exports.removeTabBarBadge = removeTabBarBadge;
exports.reportAnalytics = reportAnalytics;
exports.reportEvent = reportEvent;
exports.reportMonitor = reportMonitor;
exports.reportPerformance = reportPerformance;
exports.request = request;
exports.requestOrderPayment = requestOrderPayment;
exports.requestPayment = requestPayment;
exports.requestPolymerPayment = requestPolymerPayment;
exports.requestSubscribeMessage = requestSubscribeMessage;
exports.requirePlugin = requirePlugin;
exports.reserveChannelsLive = reserveChannelsLive;
exports.revokeBufferURL = revokeBufferURL;
exports.saveFile = saveFile;
exports.saveFileToDisk = saveFileToDisk;
exports.saveImageToPhotosAlbum = saveImageToPhotosAlbum;
exports.saveVideoToPhotosAlbum = saveVideoToPhotosAlbum;
exports.scanCode = scanCode;
exports.seekBackgroundAudio = seekBackgroundAudio;
exports.sendHCEMessage = sendHCEMessage;
exports.sendSocketMessage = sendSocketMessage;
exports.setBLEMTU = setBLEMTU;
exports.setBackgroundColor = setBackgroundColor;
exports.setBackgroundFetchToken = setBackgroundFetchToken;
exports.setBackgroundTextStyle = setBackgroundTextStyle;
exports.setClipboardData = setClipboardData;
exports.setEnable1v1Chat = setEnable1v1Chat;
exports.setEnableDebug = setEnableDebug;
exports.setInnerAudioOption = setInnerAudioOption;
exports.setKeepScreenOn = setKeepScreenOn;
exports.setNavigationBarColor = setNavigationBarColor;
exports.setNavigationBarTitle = setNavigationBarTitle;
exports.setPageInfo = setPageInfo;
exports.setScreenBrightness = setScreenBrightness;
exports.setStorage = setStorage;
exports.setStorageSync = setStorageSync;
exports.setTabBarBadge = setTabBarBadge;
exports.setTabBarItem = setTabBarItem;
exports.setTabBarStyle = setTabBarStyle;
exports.setTopBarText = setTopBarText;
exports.setVisualEffectOnCapture = setVisualEffectOnCapture;
exports.setWifiList = setWifiList;
exports.setWindowSize = setWindowSize;
exports.shareFileMessage = shareFileMessage;
exports.shareToWeRun = shareToWeRun;
exports.shareVideoMessage = shareVideoMessage;
exports.showActionSheet = showActionSheet;
exports.showLoading = showLoading;
exports.showModal = showModal;
exports.showNavigationBarLoading = showNavigationBarLoading;
exports.showRedPackage = showRedPackage;
exports.showShareImageMenu = showShareImageMenu;
exports.showShareMenu = showShareMenu;
exports.showTabBar = showTabBar;
exports.showTabBarRedDot = showTabBarRedDot;
exports.showToast = showToast;
exports.startAccelerometer = startAccelerometer;
exports.startBeaconDiscovery = startBeaconDiscovery;
exports.startBluetoothDevicesDiscovery = startBluetoothDevicesDiscovery;
exports.startCompass = startCompass;
exports.startDeviceMotionListening = startDeviceMotionListening;
exports.startFacialRecognitionVerify = startFacialRecognitionVerify;
exports.startFacialRecognitionVerifyAndUploadVideo = startFacialRecognitionVerifyAndUploadVideo;
exports.startGyroscope = startGyroscope;
exports.startHCE = startHCE;
exports.startLocalServiceDiscovery = startLocalServiceDiscovery;
exports.startLocationUpdate = startLocationUpdate;
exports.startLocationUpdateBackground = startLocationUpdateBackground;
exports.startPullDownRefresh = startPullDownRefresh;
exports.startRecord = startRecord;
exports.startSoterAuthentication = startSoterAuthentication;
exports.startWifi = startWifi;
exports.stopAccelerometer = stopAccelerometer;
exports.stopBackgroundAudio = stopBackgroundAudio;
exports.stopBeaconDiscovery = stopBeaconDiscovery;
exports.stopBluetoothDevicesDiscovery = stopBluetoothDevicesDiscovery;
exports.stopCompass = stopCompass;
exports.stopDeviceMotionListening = stopDeviceMotionListening;
exports.stopFaceDetect = stopFaceDetect;
exports.stopGyroscope = stopGyroscope;
exports.stopHCE = stopHCE;
exports.stopLocalServiceDiscovery = stopLocalServiceDiscovery;
exports.stopLocationUpdate = stopLocationUpdate;
exports.stopPullDownRefresh = stopPullDownRefresh;
exports.stopRecord = stopRecord;
exports.stopVoice = stopVoice;
exports.stopWifi = stopWifi;
exports.subscribeVoIPVideoMembers = subscribeVoIPVideoMembers;
exports.textReview = textReview;
exports.textToAudio = textToAudio;
exports.updateShareMenu = updateShareMenu;
exports.updateVoIPChatMuteConfig = updateVoIPChatMuteConfig;
exports.updateWeChatApp = updateWeChatApp;
exports.uploadFile = uploadFile;
exports.vibrateLong = vibrateLong;
exports.vibrateShort = vibrateShort;
exports.writeBLECharacteristicValue = writeBLECharacteristicValue;
//# sourceMappingURL=index.cjs.js.map
